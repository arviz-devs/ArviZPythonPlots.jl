var documenterSearchIndex = {"docs":
[{"location":"api/rcparams/#rcparams-api","page":"rcParams","title":"rcParams","text":"Pages = [\"rcparams.md\"]","category":"section"},{"location":"api/rcparams/#Reference","page":"rcParams","title":"Reference","text":"","category":"section"},{"location":"api/rcparams/#ArviZPythonPlots.rcParams","page":"rcParams","title":"ArviZPythonPlots.rcParams","text":"Class to contain ArviZ default parameters.\n\nIt is implemented as a dict with validation when setting items.\n\n\n\n\n\n\n\n","category":"constant"},{"location":"api/rcparams/#ArviZPythonPlots.rc_context-Tuple","page":"rcParams","title":"ArviZPythonPlots.rc_context","text":"\nReturn a context manager for managing rc settings.\n\nParameters\n----------\nrc : dict, optional\n    Mapping containing the rcParams to modify temporally.\nfname : str, optional\n    Filename of the file containing the rcParams to use inside the rc_context.\n\nExamples\n--------\nThis allows one to do::\n\n    with az.rc_context(fname='pystan.rc'):\n        idata = az.load_arviz_data(\"radon\")\n        az.plot_posterior(idata, var_names=[\"gamma\"])\n\nThe plot would have settings from 'screen.rc'\n\nA dictionary can also be passed to the context manager::\n\n    with az.rc_context(rc={'plot.max_subplots': None}, fname='pystan.rc'):\n        idata = az.load_arviz_data(\"radon\")\n        az.plot_posterior(idata, var_names=[\"gamma\"])\n\nThe 'rc' dictionary takes precedence over the settings loaded from\n'fname'. Passing a dictionary only is also valid.\n\n\n\n\n\n\n\n","category":"method"},{"location":"api/#api","page":"API Overview","title":"API Overview","text":"Pages = [\"style.md\", \"rcparams.md\", \"plots.md\"]\nDepth = 1","category":"section"},{"location":"examples/#Example-Gallery","page":"Examples gallery","title":"Example Gallery","text":"","category":"section"},{"location":"examples/#Autocorrelation-Plot","page":"Examples gallery","title":"Autocorrelation Plot","text":"using ArviZPythonPlots, ArviZExampleData\n\nuse_style(\"arviz-darkgrid\")\n\ndata = load_example_data(\"centered_eight\")\nplot_autocorr(data; var_names=[\"tau\", \"mu\"])\ngcf()\n\nSee plot_autocorr","category":"section"},{"location":"examples/#Bayes-Factor-Plot","page":"Examples gallery","title":"Bayes Factor Plot","text":"using ArviZ, ArviZPythonPlots\n\nuse_style(\"arviz-darkgrid\")\n\nidata = from_namedtuple((a = 1 .+ randn(5_000) ./ 2,), prior=(a = randn(5_000),))\nplot_bf(idata; var_name=\"a\", ref_val=0)\ngcf()\n\nSee plot_bf","category":"section"},{"location":"examples/#Bayesian-P-Value-Posterior-Plot","page":"Examples gallery","title":"Bayesian P-Value Posterior Plot","text":"using ArviZPythonPlots, ArviZExampleData\n\nuse_style(\"arviz-darkgrid\")\n\ndata = load_example_data(\"regression1d\")\nplot_bpv(data)\ngcf()\n\nSee plot_bpv","category":"section"},{"location":"examples/#Bayesian-P-Value-with-Median-T-Statistic-Posterior-Plot","page":"Examples gallery","title":"Bayesian P-Value with Median T Statistic Posterior Plot","text":"using ArviZPythonPlots, ArviZExampleData\n\nuse_style(\"arviz-darkgrid\")\n\ndata = load_example_data(\"regression1d\")\nplot_bpv(data; kind=\"t_stat\", t_stat=\"0.5\")\ngcf()\n\nSee plot_bpv","category":"section"},{"location":"examples/#Compare-Plot","page":"Examples gallery","title":"Compare Plot","text":"using ArviZ, ArviZPythonPlots, ArviZExampleData\n\nuse_style(\"arviz-darkgrid\")\n\nmodel_compare = compare(\n    (\n        var\"Centered 8 schools\" = load_example_data(\"centered_eight\"),\n        var\"Non-centered 8 schools\" = load_example_data(\"non_centered_eight\"),\n    ),\n)\nplot_compare(model_compare; figsize=(12, 4))\ngcf()\n\nSee compare, plot_compare","category":"section"},{"location":"examples/#Density-Plot","page":"Examples gallery","title":"Density Plot","text":"using ArviZPythonPlots, ArviZExampleData\n\nuse_style(\"arviz-darkgrid\")\n\ncentered_data = load_example_data(\"centered_eight\")\nnon_centered_data = load_example_data(\"non_centered_eight\")\nplot_density(\n    [centered_data, non_centered_data];\n    data_labels=[\"Centered\", \"Non Centered\"],\n    var_names=[\"theta\"],\n    shade=0.1,\n)\ngcf()\n\nSee plot_density","category":"section"},{"location":"examples/#Dist-Plot","page":"Examples gallery","title":"Dist Plot","text":"using ArviZPythonPlots, Distributions, Random\n\nRandom.seed!(308)\n\nuse_style(\"arviz-darkgrid\")\n\na = rand(Poisson(4), 1000)\nb = rand(Normal(0, 1), 1000)\n_, ax = subplots(1, 2; figsize=(10, 4))\nplot_dist(a; color=\"C1\", label=\"Poisson\", ax=ax[0])\nplot_dist(b; color=\"C2\", label=\"Gaussian\", ax=ax[1])\ngcf()\n\nSee plot_dist","category":"section"},{"location":"examples/#Dot-Plot","page":"Examples gallery","title":"Dot Plot","text":"using ArviZPythonPlots\n\nuse_style(\"arviz-darkgrid\")\n\ndata = randn(1000)\nfigure() # hide\nplot_dot(data; dotcolor=\"C1\", point_interval=true)\ntitle(\"Gaussian Distribution\")\ngcf()\n\nSee plot_dot","category":"section"},{"location":"examples/#ECDF-Plot","page":"Examples gallery","title":"ECDF Plot","text":"using ArviZPythonPlots, Distributions\n\nuse_style(\"arviz-darkgrid\")\n\nsample = randn(1_000)\ndist = Normal()\nplot_ecdf(sample; cdf=x -> cdf(dist, x), confidence_bands=true)\ngcf()\n\nSee plot_ecdf","category":"section"},{"location":"examples/#ELPD-Plot","page":"Examples gallery","title":"ELPD Plot","text":"using ArviZPythonPlots, ArviZExampleData\n\nuse_style(\"arviz-darkgrid\")\n\nd1 = load_example_data(\"centered_eight\")\nd2 = load_example_data(\"non_centered_eight\")\nplot_elpd(Dict(\"Centered eight\" => d1, \"Non centered eight\" => d2); xlabels=true)\ngcf()\n\nSee plot_elpd","category":"section"},{"location":"examples/#Energy-Plot","page":"Examples gallery","title":"Energy Plot","text":"using ArviZPythonPlots, ArviZExampleData\n\nuse_style(\"arviz-darkgrid\")\n\ndata = load_example_data(\"centered_eight\")\nplot_energy(data; figsize=(12, 8))\ngcf()\n\nSee plot_energy","category":"section"},{"location":"examples/#ESS-Evolution-Plot","page":"Examples gallery","title":"ESS Evolution Plot","text":"using ArviZPythonPlots, ArviZExampleData\n\nuse_style(\"arviz-darkgrid\")\n\nidata = load_example_data(\"radon\")\nplot_ess(idata; var_names=[\"b\"], kind=\"evolution\")\ngcf()\n\nSee plot_ess","category":"section"},{"location":"examples/#ESS-Local-Plot","page":"Examples gallery","title":"ESS Local Plot","text":"using ArviZPythonPlots, ArviZExampleData\n\nuse_style(\"arviz-darkgrid\")\n\nidata = load_example_data(\"non_centered_eight\")\nplot_ess(idata; var_names=[\"mu\"], kind=\"local\", marker=\"_\", ms=20, mew=2, rug=true)\ngcf()\n\nSee plot_ess","category":"section"},{"location":"examples/#ESS-Quantile-Plot","page":"Examples gallery","title":"ESS Quantile Plot","text":"using ArviZPythonPlots, ArviZExampleData\n\nuse_style(\"arviz-darkgrid\")\n\nidata = load_example_data(\"radon\")\nplot_ess(idata; var_names=[\"sigma\"], kind=\"quantile\", color=\"C4\")\ngcf()\n\nSee plot_ess","category":"section"},{"location":"examples/#Forest-Plot","page":"Examples gallery","title":"Forest Plot","text":"using ArviZPythonPlots, ArviZExampleData\n\nuse_style(\"arviz-darkgrid\")\n\ncentered_data = load_example_data(\"centered_eight\")\nnon_centered_data = load_example_data(\"non_centered_eight\")\nplot_forest(\n    [centered_data, non_centered_data];\n    model_names=[\"Centered\", \"Non Centered\"],\n    var_names=[\"mu\"],\n)\ntitle(\"Estimated theta for eight schools model\")\ngcf()\n\nSee plot_forest","category":"section"},{"location":"examples/#Ridge-Plot","page":"Examples gallery","title":"Ridge Plot","text":"using ArviZPythonPlots, ArviZExampleData\n\nuse_style(\"arviz-darkgrid\")\n\nrugby_data = load_example_data(\"rugby\")\nplot_forest(\n    rugby_data;\n    kind=\"ridgeplot\",\n    var_names=[\"defs\"],\n    linewidth=4,\n    combined=true,\n    ridgeplot_overlap=1.5,\n    colors=\"blue\",\n    figsize=(9, 4),\n)\ntitle(\"Relative defensive strength\\nof Six Nation rugby teams\")\ngcf()\n\nSee plot_forest","category":"section"},{"location":"examples/#Plot-HDI","page":"Examples gallery","title":"Plot HDI","text":"using Random\nusing ArviZPythonPlots\n\nRandom.seed!(308)\n\nuse_style(\"arviz-darkgrid\")\n\nx_data = randn(100)\ny_data = 2 .+ x_data .* 0.5\ny_data_rep = 0.5 .* randn(200, 100) .+ transpose(y_data)\n\nplot(x_data, y_data; color=\"C6\")\nplot_hdi(x_data, y_data_rep; color=\"k\", plot_kwargs=Dict(\"ls\" => \"--\"))\ngcf()\n\nSee plot_hdi","category":"section"},{"location":"examples/#Joint-Plot","page":"Examples gallery","title":"Joint Plot","text":"using ArviZPythonPlots, ArviZExampleData\n\nuse_style(\"arviz-darkgrid\")\n\ndata = load_example_data(\"non_centered_eight\")\nplot_pair(\n    data;\n    var_names=[\"theta\"],\n    coords=Dict(\"school\" => [\"Choate\", \"Phillips Andover\"]),\n    kind=\"hexbin\",\n    marginals=true,\n    figsize=(10, 10),\n)\ngcf()\n\nSee plot_pair","category":"section"},{"location":"examples/#KDE-Plot","page":"Examples gallery","title":"KDE Plot","text":"using ArviZPythonPlots, ArviZExampleData\n\nuse_style(\"arviz-darkgrid\")\n\ndata = load_example_data(\"centered_eight\")\n\n## Combine different posterior draws from different chains\nobs = data.posterior_predictive.obs\nsize_obs = size(obs)\ny_hat = reshape(obs, prod(size_obs[1:2]), size_obs[3:end]...)\n\nplot_kde(\n    y_hat;\n    label=\"Estimated Effect\\n of SAT Prep\",\n    rug=true,\n    plot_kwargs=Dict(\"linewidth\" => 2, \"color\" => \"black\"),\n    rug_kwargs=Dict(\"color\" => \"black\"),\n)\ngcf()\n\nSee plot_kde","category":"section"},{"location":"examples/#2d-KDE","page":"Examples gallery","title":"2d KDE","text":"using Random\nusing ArviZPythonPlots\n\nRandom.seed!(308)\n\nuse_style(\"arviz-darkgrid\")\n\nplot_kde(rand(100), rand(100))\ngcf()\n\nSee plot_kde","category":"section"},{"location":"examples/#KDE-Quantiles-Plot","page":"Examples gallery","title":"KDE Quantiles Plot","text":"using Random\nusing Distributions\nusing ArviZPythonPlots\n\nRandom.seed!(308)\n\nuse_style(\"arviz-darkgrid\")\n\ndist = rand(Beta(rand(Uniform(0.5, 10)), 5), 1000)\nplot_kde(dist; quantiles=[0.25, 0.5, 0.75])\ngcf()\n\nSee plot_kde","category":"section"},{"location":"examples/#Pareto-Shape-Plot","page":"Examples gallery","title":"Pareto Shape Plot","text":"using ArviZ, ArviZPythonPlots, ArviZExampleData\n\nuse_style(\"arviz-darkgrid\")\n\nidata = load_example_data(\"radon\")\nloo_data = loo(idata)\nplot_khat(loo_data; show_bins=true)\ngcf()\n\nSee loo, plot_khat","category":"section"},{"location":"examples/#LOO-PIT-ECDF-Plot","page":"Examples gallery","title":"LOO-PIT ECDF Plot","text":"using ArviZPythonPlots, ArviZExampleData\n\nuse_style(\"arviz-darkgrid\")\n\nidata = load_example_data(\"radon\")\n\nplot_loo_pit(idata; y=\"y\", ecdf=true, color=\"maroon\")\ngcf()\n\nSee loo_pit, plot_loo_pit","category":"section"},{"location":"examples/#LOO-PIT-Overlay-Plot","page":"Examples gallery","title":"LOO-PIT Overlay Plot","text":"using ArviZPythonPlots, ArviZExampleData\n\nuse_style(\"arviz-darkgrid\")\n\nidata = load_example_data(\"non_centered_eight\")\nplot_loo_pit(; idata, y=\"obs\", color=\"indigo\")\ngcf()\n\nSee loo_pit, plot_loo_pit","category":"section"},{"location":"examples/#Quantile-Monte-Carlo-Standard-Error-Plot","page":"Examples gallery","title":"Quantile Monte Carlo Standard Error Plot","text":"using ArviZPythonPlots, ArviZExampleData\n\nuse_style(\"arviz-darkgrid\")\n\ndata = load_example_data(\"centered_eight\")\nplot_mcse(data; var_names=[\"tau\", \"mu\"], rug=true, extra_methods=true)\ngcf()\n\nSee plot_mcse","category":"section"},{"location":"examples/#Quantile-MCSE-Errobar-Plot","page":"Examples gallery","title":"Quantile MCSE Errobar Plot","text":"using ArviZPythonPlots, ArviZExampleData\n\nuse_style(\"arviz-darkgrid\")\n\ndata = load_example_data(\"radon\")\nplot_mcse(data; var_names=[\"sigma_a\"], color=\"C4\", errorbar=true)\ngcf()\n\nSee plot_mcse","category":"section"},{"location":"examples/#Pair-Plot","page":"Examples gallery","title":"Pair Plot","text":"using ArviZPythonPlots, ArviZExampleData\n\nuse_style(\"arviz-darkgrid\")\n\ncentered = load_example_data(\"centered_eight\")\ncoords = Dict(\"school\" => [\"Choate\", \"Deerfield\"])\nplot_pair(\n    centered; var_names=[\"theta\", \"mu\", \"tau\"], coords, divergences=true, textsize=22\n)\ngcf()\n\nSee plot_pair","category":"section"},{"location":"examples/#Hexbin-Pair-Plot","page":"Examples gallery","title":"Hexbin Pair Plot","text":"using ArviZPythonPlots, ArviZExampleData\n\nuse_style(\"arviz-darkgrid\")\n\ncentered = load_example_data(\"centered_eight\")\ncoords = Dict(\"school\" => [\"Choate\", \"Deerfield\"])\nplot_pair(\n    centered;\n    var_names=[\"theta\", \"mu\", \"tau\"],\n    kind=\"hexbin\",\n    coords,\n    colorbar=true,\n    divergences=true,\n)\ngcf()\n\nSee plot_pair","category":"section"},{"location":"examples/#KDE-Pair-Plot","page":"Examples gallery","title":"KDE Pair Plot","text":"using ArviZPythonPlots, ArviZExampleData\n\nuse_style(\"arviz-darkgrid\")\n\ncentered = load_example_data(\"centered_eight\")\ncoords = Dict(\"school\" => [\"Choate\", \"Deerfield\"])\nplot_pair(\n    centered;\n    var_names=[\"theta\", \"mu\", \"tau\"],\n    kind=\"kde\",\n    coords,\n    divergences=true,\n    textsize=22,\n)\ngcf()\n\nSee plot_pair","category":"section"},{"location":"examples/#Point-Estimate-Pair-Plot","page":"Examples gallery","title":"Point Estimate Pair Plot","text":"using ArviZPythonPlots, ArviZExampleData\n\nuse_style(\"arviz-darkgrid\")\n\ncentered = load_example_data(\"centered_eight\")\ncoords = Dict(\"school\" => [\"Choate\", \"Deerfield\"])\nplot_pair(\n    centered;\n    var_names=[\"mu\", \"theta\"],\n    kind=[\"scatter\", \"kde\"],\n    kde_kwargs=Dict(\"fill_last\" => false),\n    marginals=true,\n    coords,\n    point_estimate=\"median\",\n    figsize=(10, 8),\n)\ngcf()\n\nSee plot_pair","category":"section"},{"location":"examples/#Parallel-Plot","page":"Examples gallery","title":"Parallel Plot","text":"using ArviZPythonPlots, ArviZExampleData\n\nuse_style(\"arviz-darkgrid\")\n\ndata = load_example_data(\"centered_eight\")\nax = plot_parallel(data; var_names=[\"theta\", \"tau\", \"mu\"])\nax.set_xticklabels(ax.get_xticklabels(); rotation=70)\ndraw()\ngcf()\n\nSee plot_parallel","category":"section"},{"location":"examples/#Posterior-Plot","page":"Examples gallery","title":"Posterior Plot","text":"using ArviZPythonPlots, ArviZExampleData\n\nuse_style(\"arviz-darkgrid\")\n\ndata = load_example_data(\"centered_eight\")\ncoords = Dict(\"school\" => [\"Choate\"])\nplot_posterior(data; var_names=[\"mu\", \"theta\"], coords, rope=(-1, 1))\ngcf()\n\nSee plot_posterior","category":"section"},{"location":"examples/#Posterior-Predictive-Check-Plot","page":"Examples gallery","title":"Posterior Predictive Check Plot","text":"using ArviZPythonPlots, ArviZExampleData\n\nuse_style(\"arviz-darkgrid\")\n\ndata = load_example_data(\"non_centered_eight\")\nplot_ppc(data; data_pairs=Dict(\"obs\" => \"obs\"), alpha=0.03, figsize=(12, 6), textsize=14)\ngcf()\n\nSee plot_ppc","category":"section"},{"location":"examples/#Posterior-Predictive-Check-Cumulative-Plot","page":"Examples gallery","title":"Posterior Predictive Check Cumulative Plot","text":"using ArviZPythonPlots, ArviZExampleData\n\nuse_style(\"arviz-darkgrid\")\n\ndata = load_example_data(\"non_centered_eight\")\nplot_ppc(data; alpha=0.3, kind=\"cumulative\", figsize=(12, 6), textsize=14)\ngcf()\n\nSee plot_ppc","category":"section"},{"location":"examples/#Rank-Plot","page":"Examples gallery","title":"Rank Plot","text":"using ArviZPythonPlots, ArviZExampleData\n\nuse_style(\"arviz-darkgrid\")\n\ndata = load_example_data(\"centered_eight\")\nplot_rank(data; var_names=[\"tau\", \"mu\"])\ngcf()\n\nSee plot_rank","category":"section"},{"location":"examples/#Regression-Plot","page":"Examples gallery","title":"Regression Plot","text":"using ArviZ, ArviZPythonPlots, ArviZExampleData, DimensionalData\n\nuse_style(\"arviz-darkgrid\")\n\ndata = load_example_data(\"regression1d\")\nx = range(0, 1; length=100)\nposterior = data.posterior\nconstant_data = convert_to_dataset((; x); default_dims=())\ny_model = broadcast_dims(muladd, posterior.intercept, posterior.slope, constant_data.x)\nposterior = merge(posterior, (; y_model))\ndata = merge(data, InferenceData(; posterior, constant_data))\nplot_lm(\"y\"; idata=data, x=\"x\", y_model=\"y_model\")\ngcf()\n\nSee plot_lm","category":"section"},{"location":"examples/#Separation-Plot","page":"Examples gallery","title":"Separation Plot","text":"using ArviZPythonPlots, ArviZExampleData\n\nuse_style(\"arviz-darkgrid\")\n\ndata = load_example_data(\"classification10d\")\nplot_separation(data; y=\"outcome\", y_hat=\"outcome\", figsize=(8, 1))\ngcf()\n\nSee plot_separation","category":"section"},{"location":"examples/#Trace-Plot","page":"Examples gallery","title":"Trace Plot","text":"using ArviZPythonPlots, ArviZExampleData\n\nuse_style(\"arviz-darkgrid\")\n\ndata = load_example_data(\"non_centered_eight\")\nplot_trace(data; var_names=[\"tau\", \"mu\"])\ngcf()\n\nSee plot_trace","category":"section"},{"location":"examples/#Violin-Plot","page":"Examples gallery","title":"Violin Plot","text":"using ArviZPythonPlots, ArviZExampleData\n\nuse_style(\"arviz-darkgrid\")\n\ndata = load_example_data(\"non_centered_eight\")\nplot_violin(data; var_names=[\"mu\", \"tau\"])\ngcf()\n\nSee plot_violin","category":"section"},{"location":"examples/#Styles","page":"Examples gallery","title":"Styles","text":"using ArviZPythonPlots, Distributions, PythonCall\n\nx = range(0, 1; length=100)\ndist = pdf.(Beta(2, 5), x)\n\nstyle_list = [\n    \"default\",\n    [\"default\", \"arviz-colors\"],\n    \"arviz-darkgrid\",\n    \"arviz-whitegrid\",\n    \"arviz-white\",\n    \"arviz-grayscale\",\n    [\"arviz-white\", \"arviz-redish\"],\n    [\"arviz-white\", \"arviz-bluish\"],\n    [\"arviz-white\", \"arviz-orangish\"],\n    [\"arviz-white\", \"arviz-brownish\"],\n    [\"arviz-white\", \"arviz-purplish\"],\n    [\"arviz-white\", \"arviz-cyanish\"],\n    [\"arviz-white\", \"arviz-greenish\"],\n    [\"arviz-white\", \"arviz-royish\"],\n    [\"arviz-white\", \"arviz-viridish\"],\n    [\"arviz-white\", \"arviz-plasmish\"],\n    \"arviz-doc\",\n    \"arviz-docgrid\",\n]\n\nfig = figure(; figsize=(20, 10))\nfor (idx, style) in enumerate(style_list)\n    pywith(pyplot.style.context(style; after_reset=true)) do _\n        ax = fig.add_subplot(5, 4, idx; label=idx)\n        colors = pyplot.rcParams[\"axes.prop_cycle\"].by_key()[\"color\"]\n        for i in 0:(length(colors) - 1)\n            ax.plot(x, dist .- i, \"C$i\"; label=\"C$i\")\n        end\n        ax.set_title(style)\n        ax.set_xlabel(\"x\")\n        ax.set_ylabel(\"f(x)\"; rotation=0, labelpad=15)\n        ax.set_xticklabels([])\n    end\nend\ntight_layout()\ngcf()","category":"section"},{"location":"api/style/#style-api","page":"Plotting styles","title":"Plotting styles","text":"Pages = [\"style.md\"]","category":"section"},{"location":"api/style/#Reference","page":"Plotting styles","title":"Reference","text":"","category":"section"},{"location":"api/style/#ArviZPythonPlots.styles-Tuple{}","page":"Plotting styles","title":"ArviZPythonPlots.styles","text":"styles() -> Vector{String}\n\nGet all available matplotlib styles for use with use_style\n\n\n\n\n\n","category":"method"},{"location":"api/style/#ArviZPythonPlots.use_style-Tuple{Any}","page":"Plotting styles","title":"ArviZPythonPlots.use_style","text":"use_style(style::String)\nuse_style(style::Vector{String})\n\nUse matplotlib style settings from a style specification style.\n\nThe style name of \"default\" is reserved for reverting back to the default style settings.\n\nArviZ-specific styles include [\"arviz-whitegrid\", \"arviz-darkgrid\", \"arviz-colors\", \"arviz-white\", \"arviz-doc\"]. To see all available style specifications, use styles().\n\nIf a Vector of styles is provided, they are applied from first to last.\n\n\n\n\n\n","category":"method"},{"location":"#ArviZPythonPlots.jl","page":"Home","title":"ArviZPythonPlots.jl","text":"ArviZPythonPlots.jl provides PyPlot-compatible plotting functions for exploratory analysis of Bayesian models using ArviZ.jl. It uses PythonCall.jl to provide an interface for using the plotting functions in Python ArviZ with Julia types. It also re-exports all methods exported by PythonPlot.jl.\n\nFor details, see the Example Gallery or the API.","category":"section"},{"location":"#installation","page":"Home","title":"Installation","text":"To install ArviZPythonPlots.jl, we first need to install Python ArviZ. From the Julia REPL, type ] to enter the Pkg REPL mode and run\n\npkg> add ArviZPythonPlots","category":"section"},{"location":"api/plots/#plots-api","page":"Plotting functions","title":"Plotting functions","text":"Pages = [\"plots.md\"]","category":"section"},{"location":"api/plots/#Reference","page":"Plotting functions","title":"Reference","text":"","category":"section"},{"location":"api/plots/#ArviZPythonPlots.plot_autocorr-Tuple","page":"Plotting functions","title":"ArviZPythonPlots.plot_autocorr","text":"Bar plot of the autocorrelation function (ACF) for a sequence of data.\n\nThe ACF plots are helpful as a convergence diagnostic for posteriors from MCMC\nsamples which display autocorrelation.\n\nParameters\n----------\ndata : InferenceData\n    Any object that can be converted to an :class:`arviz.InferenceData` object\n    refer to documentation of :func:`arviz.convert_to_dataset` for details\nvar_names : list of str, optional\n    Variables to be plotted. Prefix the variables by ``~`` when you want to exclude\n    them from the plot. See :ref:`this section <common_var_names>` for usage examples.\nfilter_vars : {None, \"like\", \"regex\"}, default None\n    If `None` (default), interpret `var_names` as the real variables names. If \"like\",\n    interpret `var_names` as substrings of the real variables names. If \"regex\",\n    interpret `var_names` as regular expressions on the real variables names. See\n    :ref:`this section <common_filter_vars>` for usage examples.\ncoords: mapping, optional\n    Coordinates of var_names to be plotted. Passed to :meth:`xarray.Dataset.sel`\nmax_lag : int, optional\n    Maximum lag to calculate autocorrelation. By Default, the plot displays the\n    first 100 lag or the total number of draws, whichever is smaller.\ncombined : bool, default False\n    Flag for combining multiple chains into a single chain. If False, chains will be\n    plotted separately.\ngrid : tuple, optional\n    Number of rows and columns. Defaults to None, the rows and columns are\n    automatically inferred. See :ref:`this section <common_grid>` for usage examples.\nfigsize : (float, float), optional\n    Figure size. If None it will be defined automatically.\n    Note this is not used if `ax` is supplied.\ntextsize : float, optional\n    Text size scaling factor for labels, titles and lines. If None it will be autoscaled based\n    on `figsize`.\nlabeller : Labeller, optional\n    Class providing the method ``make_label_vert`` to generate the labels in the plot titles.\n    Read the :ref:`label_guide` for more details and usage examples.\nax : 2D array-like of matplotlib_axes or bokeh_figure, optional\n    A 2D array of locations into which to plot the densities. If not supplied, ArviZ will create\n    its own array of plot areas (and return it).\nbackend : {\"matplotlib\", \"bokeh\"}, default \"matplotlib\"\n    Select plotting backend.\nbackend_config : dict, optional\n    Currently specifies the bounds to use for bokeh axes. Defaults to value set in ``rcParams``.\nbackend_kwargs : dict, optional\n    These are kwargs specific to the backend being used, passed to\n    :func:`matplotlib.pyplot.subplots` or :class:`bokeh.plotting.figure`.\n    For additional documentation check the plotting method of the backend.\nshow : bool, optional\n    Call backend show function.\n\nReturns\n-------\naxes : matplotlib_axes or bokeh_figures\n\nSee Also\n--------\nautocov : Compute autocovariance estimates for every lag for the input array.\nautocorr : Compute autocorrelation using FFT for every lag for the input array.\n\nExamples\n--------\nPlot default autocorrelation\n\n.. plot::\n    :context: close-figs\n\n    >>> import arviz as az\n    >>> data = az.load_arviz_data('centered_eight')\n    >>> az.plot_autocorr(data)\n\nPlot subset variables by specifying variable name exactly\n\n.. plot::\n    :context: close-figs\n\n    >>> az.plot_autocorr(data, var_names=['mu', 'tau'] )\n\n\nCombine chains by variable and select variables by excluding some with partial naming\n\n.. plot::\n    :context: close-figs\n\n    >>> az.plot_autocorr(data, var_names=['~thet'], filter_vars=\"like\", combined=True)\n\n\nSpecify maximum lag (x axis bound)\n\n.. plot::\n    :context: close-figs\n\n    >>> az.plot_autocorr(data, var_names=['mu', 'tau'], max_lag=200, combined=True)\n\n\n\n\n\n\n\n","category":"method"},{"location":"api/plots/#ArviZPythonPlots.plot_bf-Tuple","page":"Plotting functions","title":"ArviZPythonPlots.plot_bf","text":"Approximated Bayes Factor for comparing hypothesis of two nested models.\n\nThe Bayes factor is estimated by comparing a model (H1) against a model in which the\nparameter of interest has been restricted to be a point-null (H0). This computation\nassumes the models are nested and thus H0 is a special case of H1.\n\nNotes\n-----\nThe bayes Factor is approximated as the Savage-Dickey density ratio\nalgorithm presented in [1]_.\n\nParameters\n----------\nidata : InferenceData\n    Any object that can be converted to an :class:`arviz.InferenceData` object\n    Refer to documentation of :func:`arviz.convert_to_dataset` for details.\nvar_name : str, optional\n    Name of variable we want to test.\nprior : numpy.array, optional\n    In case we want to use different prior, for example for sensitivity analysis.\nref_val : int, default 0\n    Point-null for Bayes factor estimation.\ncolors : tuple, default ('C0', 'C1')\n    Tuple of valid Matplotlib colors. First element for the prior, second for the posterior.\nfigsize : (float, float), optional\n    Figure size. If `None` it will be defined automatically.\ntextsize : float, optional\n    Text size scaling factor for labels, titles and lines. If `None` it will be auto\n    scaled based on `figsize`.\nplot_kwargs : dict, optional\n    Additional keywords passed to :func:`matplotlib.pyplot.plot`.\nhist_kwargs : dict, optional\n    Additional keywords passed to :func:`arviz.plot_dist`. Only works for discrete variables.\nax : axes, optional\n    :class:`matplotlib.axes.Axes` or :class:`bokeh.plotting.Figure`.\nbackend : {\"matplotlib\", \"bokeh\"}, default \"matplotlib\"\n    Select plotting backend.\nbackend_kwargs : dict, optional\n    These are kwargs specific to the backend being used, passed to\n    :func:`matplotlib.pyplot.subplots` or :class:`bokeh.plotting.figure`.\n    For additional documentation check the plotting method of the backend.\nshow : bool, optional\n    Call backend show function.\n\nReturns\n-------\ndict : A dictionary with BF10 (Bayes Factor 10 (H1/H0 ratio), and BF01 (H0/H1 ratio).\naxes : matplotlib_axes or bokeh_figure\n\nReferences\n----------\n.. [1] Heck, D., 2019. A caveat on the Savage-Dickey density ratio:\n   The case of computing Bayes factors for regression parameters.\n\nExamples\n--------\nModerate evidence indicating that the parameter \"a\" is different from zero.\n\n.. plot::\n    :context: close-figs\n\n    >>> import numpy as np\n    >>> import arviz as az\n    >>> idata = az.from_dict(posterior={\"a\":np.random.normal(1, 0.5, 5000)},\n    ...     prior={\"a\":np.random.normal(0, 1, 5000)})\n    >>> az.plot_bf(idata, var_name=\"a\", ref_val=0)\n\n\n\n\n\n\n\n\n","category":"method"},{"location":"api/plots/#ArviZPythonPlots.plot_bpv-Tuple","page":"Plotting functions","title":"ArviZPythonPlots.plot_bpv","text":"Plot Bayesian p-value for observed data and Posterior/Prior predictive.\n\nParameters\n----------\ndata : InferenceData\n    :class:`arviz.InferenceData` object containing the observed and\n    posterior/prior predictive data.\nkind : {\"u_value\", \"p_value\", \"t_stat\"}, default \"u_value\"\n    Specify the kind of plot:\n\n    * The ``kind=\"p_value\"`` computes :math:`p := p(y* \\leq y | y)`.\n      This is the probability of the data y being larger or equal than the predicted data y*.\n      The ideal value is 0.5 (half the predictions below and half above the data).\n    * The ``kind=\"u_value\"`` argument computes :math:`p_i := p(y_i* \\leq y_i | y)`.\n      i.e. like a p_value but per observation :math:`y_i`. This is also known as marginal\n      p_value. The ideal distribution is uniform. This is similar to the LOO-PIT\n      calculation/plot, the difference is than in LOO-pit plot we compute\n      :math:`pi = p(y_i* r \\leq y_i | y_{-i} )`, where :math:`y_{-i}`,\n      is all other data except :math:`y_i`.\n    * The ``kind=\"t_stat\"`` argument computes :math:`:= p(T(y)* \\leq T(y) | y)`\n      where T is any test statistic. See ``t_stat`` argument below for details\n      of available options.\n\nt_stat : str, float, or callable, default \"median\"\n    Test statistics to compute from the observations and predictive distributions.\n    Allowed strings are “mean”, “median” or “std”. Alternative a quantile can be passed\n    as a float (or str) in the interval (0, 1). Finally a user defined function is also\n    acepted, see examples section for details.\nbpv : bool, default True\n    If True add the Bayesian p_value to the legend when ``kind = t_stat``.\nplot_mean : bool, default True\n    Whether or not to plot the mean test statistic.\nreference : {\"analytical\", \"samples\", None}, default \"analytical\"\n    How to compute the distributions used as reference for ``kind=u_values``\n    or ``kind=p_values``. Use `None` to not plot any reference.\nsmoothing : bool, optional\n    If True and the data has integer dtype, smooth the data before computing the p-values,\n    u-values or tstat. By default, True when `kind` is \"u_value\" and False otherwise.\nmse : bool, default False\n    Show scaled mean square error between uniform distribution and marginal p_value\n    distribution.\nn_ref : int, default 100\n    Number of reference distributions to sample when ``reference=samples``.\nhdi_prob : float, optional\n    Probability for the highest density interval for the analytical reference distribution when\n    ``kind=u_values``. Should be in the interval (0, 1]. Defaults to the\n    rcParam ``stats.ci_prob``. See :ref:`this section <common_hdi_prob>` for usage examples.\ncolor : str, optional\n    Matplotlib color\ngrid : tuple, optional\n    Number of rows and columns. By default, the rows and columns are\n    automatically inferred. See :ref:`this section <common_grid>` for usage examples.\nfigsize : (float, float), optional\n    Figure size. If None it will be defined automatically.\ntextsize : float, optional\n    Text size scaling factor for labels, titles and lines. If None it will be autoscaled based\n    on `figsize`.\ndata_pairs : dict, optional\n    Dictionary containing relations between observed data and posterior/prior predictive data.\n    Dictionary structure:\n\n    - key = data var_name\n    - value = posterior/prior predictive var_name\n\n    For example, ``data_pairs = {'y' : 'y_hat'}``\n    If None, it will assume that the observed data and the posterior/prior\n    predictive data have the same variable name.\nLabeller : Labeller, optional\n    Class providing the method ``make_pp_label`` to generate the labels in the plot titles.\n    Read the :ref:`label_guide` for more details and usage examples.\nvar_names : list of str, optional\n    Variables to be plotted. If `None` all variable are plotted. Prefix the variables by ``~``\n    when you want to exclude them from the plot. See the :ref:`this section <common_var_names>`\n    for usage examples. See :ref:`this section <common_var_names>` for usage examples.\nfilter_vars : {None, \"like\", \"regex\"}, default None\n    If `None` (default), interpret `var_names` as the real variables names. If \"like\",\n    interpret `var_names` as substrings of the real variables names. If \"regex\",\n    interpret `var_names` as regular expressions on the real variables names. See\n    :ref:`this section <common_filter_vars>` for usage examples.\ncoords : dict, optional\n    Dictionary mapping dimensions to selected coordinates to be plotted.\n    Dimensions without a mapping specified will include all coordinates for\n    that dimension. Defaults to including all coordinates for all\n    dimensions if None. See :ref:`this section <common_coords>` for usage examples.\nflatten : list, optional\n    List of dimensions to flatten in observed_data. Only flattens across the coordinates\n    specified in the coords argument. Defaults to flattening all of the dimensions.\nflatten_pp : list, optional\n    List of dimensions to flatten in posterior_predictive/prior_predictive. Only flattens\n    across the coordinates specified in the coords argument. Defaults to flattening all\n    of the dimensions. Dimensions should match flatten excluding dimensions for data_pairs\n    parameters. If `flatten` is defined and `flatten_pp` is None, then ``flatten_pp=flatten``.\nlegend : bool, default True\n    Add legend to figure.\nax : 2D array-like of matplotlib_axes or bokeh_figure, optional\n    A 2D array of locations into which to plot the densities. If not supplied, ArviZ will create\n    its own array of plot areas (and return it).\nbackend : str, optional\n    Select plotting backend {\"matplotlib\", \"bokeh\"}. Default \"matplotlib\".\nplot_ref_kwargs :  dict, optional\n    Extra keyword arguments to control how reference is represented.\n    Passed to :meth:`matplotlib.axes.Axes.plot` or\n    :meth:`matplotlib.axes.Axes.axhspan` (when ``kind=u_value``\n    and ``reference=analytical``).\nbackend_kwargs : bool, optional\n    These are kwargs specific to the backend being used, passed to\n    :func:`matplotlib.pyplot.subplots` or :class:`bokeh.plotting.figure`.\n    For additional documentation check the plotting method of the backend.\ngroup : {\"posterior\", \"prior\"}, default \"posterior\"\n    Specifies which InferenceData group should be plotted. If \"posterior\", then the values\n    in `posterior_predictive` group are compared to the ones in `observed_data`, if \"prior\" then\n    the same comparison happens, but with the values in `prior_predictive` group.\nshow : bool, optional\n    Call backend show function.\n\nReturns\n-------\naxes : 2D ndarray of matplotlib_axes or bokeh_figure\n\nSee Also\n--------\nplot_ppc : Plot for posterior/prior predictive checks.\nplot_loo_pit : Plot Leave-One-Out probability integral transformation (PIT) predictive checks.\nplot_dist_comparison : Plot to compare fitted and unfitted distributions.\n\nReferences\n----------\n* Gelman et al. (2013) see http://www.stat.columbia.edu/~gelman/book/ pages 151-153 for details\n\nNotes\n-----\nDiscrete data is smoothed before computing either p-values or u-values using the\nfunction :func:`~arviz.smooth_data` if the data is integer type\nand the smoothing parameter is True.\n\nExamples\n--------\nPlot Bayesian p_values.\n\n.. plot::\n    :context: close-figs\n\n    >>> import arviz as az\n    >>> data = az.load_arviz_data(\"regression1d\")\n    >>> az.plot_bpv(data, kind=\"p_value\")\n\nPlot custom test statistic comparison.\n\n.. plot::\n    :context: close-figs\n\n    >>> import arviz as az\n    >>> data = az.load_arviz_data(\"regression1d\")\n    >>> az.plot_bpv(data, kind=\"t_stat\", t_stat=lambda x:np.percentile(x, q=50, axis=-1))\n\n\n\n\n\n\n\n","category":"method"},{"location":"api/plots/#ArviZPythonPlots.plot_compare-Tuple","page":"Plotting functions","title":"ArviZPythonPlots.plot_compare","text":"Summary plot for model comparison.\n\nModels are compared based on their expected log pointwise predictive density (ELPD).\nThis plot is in the style of the one used in [2]_. Chapter 6 in the first edition\nor 7 in the second.\n\nNotes\n-----\nThe ELPD is estimated either by Pareto smoothed importance sampling leave-one-out\ncross-validation (LOO) or using the widely applicable information criterion (WAIC).\nWe recommend LOO in line with the work presented by [1]_.\n\nParameters\n----------\ncomp_df : pandas.DataFrame\n    Result of the :func:`arviz.compare` method.\ninsample_dev : bool, default False\n    Plot in-sample ELPD, that is the value of the information criteria without the\n    penalization given by the effective number of parameters (p_loo or p_waic).\nplot_standard_error : bool, default True\n    Plot the standard error of the ELPD.\nplot_ic_diff : bool, default False\n    Plot standard error of the difference in ELPD between each model\n    and the top-ranked model.\norder_by_rank : bool, default True\n    If True ensure the best model is used as reference.\nlegend : bool, default False\n    Add legend to figure.\nfigsize : (float, float), optional\n    If `None`, size is (6, num of models) inches.\ntitle : bool, default True\n    Show a tittle with a description of how to interpret the plot.\ntextsize : float, optional\n    Text size scaling factor for labels, titles and lines. If `None` it will be autoscaled based\n    on `figsize`.\nlabeller : Labeller, optional\n    Class providing the method ``make_label_vert`` to generate the labels in the plot titles.\n    Read the :ref:`label_guide` for more details and usage examples.\nplot_kwargs : dict, optional\n    Optional arguments for plot elements. Currently accepts 'color_ic',\n    'marker_ic', 'color_insample_dev', 'marker_insample_dev', 'color_dse',\n    'marker_dse', 'ls_min_ic' 'color_ls_min_ic',  'fontsize'\nax : matplotlib_axes or bokeh_figure, optional\n    Matplotlib axes or bokeh figure.\nbackend : {\"matplotlib\", \"bokeh\"}, default \"matplotlib\"\n    Select plotting backend.\nbackend_kwargs : bool, optional\n    These are kwargs specific to the backend being used, passed to\n    :func:`matplotlib.pyplot.subplots` or :class:`bokeh.plotting.figure`.\n    For additional documentation check the plotting method of the backend.\nshow : bool, optional\n    Call backend show function.\n\nReturns\n-------\naxes : matplotlib_axes or bokeh_figure\n\nSee Also\n--------\nplot_elpd : Plot pointwise elpd differences between two or more models.\ncompare : Compare models based on PSIS-LOO loo or WAIC waic cross-validation.\nloo : Compute Pareto-smoothed importance sampling leave-one-out cross-validation (PSIS-LOO-CV).\nwaic : Compute the widely applicable information criterion.\n\nReferences\n----------\n.. [1] Vehtari et al. (2016). Practical Bayesian model evaluation using leave-one-out\n   cross-validation and WAIC https://arxiv.org/abs/1507.04544\n\n.. [2] McElreath R. (2022). Statistical Rethinking A Bayesian Course with Examples in\n   R and Stan, Second edition, CRC Press.\n\nExamples\n--------\nShow default compare plot\n\n.. plot::\n    :context: close-figs\n\n    >>> import arviz as az\n    >>> model_compare = az.compare({'Centered 8 schools': az.load_arviz_data('centered_eight'),\n    >>>                  'Non-centered 8 schools': az.load_arviz_data('non_centered_eight')})\n    >>> az.plot_compare(model_compare)\n\nInclude the in-sample ELDP\n\n.. plot::\n    :context: close-figs\n\n    >>> az.plot_compare(model_compare, insample_dev=True)\n\n\n\n\n\n\n\n\n","category":"method"},{"location":"api/plots/#ArviZPythonPlots.plot_density-Tuple","page":"Plotting functions","title":"ArviZPythonPlots.plot_density","text":"Generate KDE plots for continuous variables and histograms for discrete ones.\n\nPlots are truncated at their 100*(1-alpha)% highest density intervals. Plots are grouped per\nvariable and colors assigned to models.\n\nParameters\n----------\ndata : InferenceData or iterable of InferenceData\n    Any object that can be converted to an :class:`arviz.InferenceData` object, or an Iterator\n    returning a sequence of such objects.\n    Refer to documentation of :func:`arviz.convert_to_dataset` for details.\ngroup : {\"posterior\", \"prior\"}, default \"posterior\"\n    Specifies which InferenceData group should be plotted. If \"posterior\", then the values\n    in `posterior_predictive` group are compared to the ones in `observed_data`, if \"prior\" then\n    the same comparison happens, but with the values in `prior_predictive` group.\ndata_labels : list of str, default None\n    List with names for the datasets passed as \"data.\" Useful when plotting more than one\n    dataset.  Must be the same shape as the data parameter.\nvar_names : list of str, optional\n    List of variables to plot. If multiple datasets are supplied and `var_names` is not None,\n    will print the same set of variables for each dataset. Defaults to None, which results in\n    all the variables being plotted.\nfilter_vars : {None, \"like\", \"regex\"}, default None\n    If `None` (default), interpret `var_names` as the real variables names. If \"like\",\n    interpret `var_names` as substrings of the real variables names. If \"regex\",\n    interpret `var_names` as regular expressions on the real variables names. See\n    :ref:`this section <common_filter_vars>` for usage examples.\ncombine_dims : set_like of str, optional\n    List of dimensions to reduce. Defaults to reducing only the \"chain\" and \"draw\" dimensions.\n    See :ref:`this section <common_combine_dims>` for usage examples.\ntransform : callable\n    Function to transform data (defaults to `None` i.e. the identity function).\nhdi_prob : float, default 0.94\n    Probability for the highest density interval. Should be in the interval (0, 1].\n    See :ref:`this section <common_hdi_prob>` for usage examples.\npoint_estimate : str, optional\n    Plot point estimate per variable. Values should be 'mean', 'median', 'mode' or None.\n    Defaults to 'auto' i.e. it falls back to default set in ``rcParams``.\ncolors : str or list of str, optional\n    List with valid matplotlib colors, one color per model. Alternative a string can be passed.\n    If the string is `cycle`, it will automatically choose a color per model from matplotlib's\n    cycle. If a single color is passed, e.g. 'k', 'C2' or 'red' this color will be used for all\n    models. Defaults to `cycle`.\noutline : bool, default True\n    Use a line to draw KDEs and histograms.\nhdi_markers : str\n    A valid `matplotlib.markers` like 'v', used to indicate the limits of the highest density\n    interval. Defaults to empty string (no marker).\nshade : float, default 0\n    Alpha blending value for the shaded area under the curve, between 0 (no shade) and 1\n    (opaque).\nbw : float or str, optional\n    If numeric, indicates the bandwidth and must be positive.\n    If str, indicates the method to estimate the bandwidth and must be\n    one of \"scott\", \"silverman\", \"isj\" or \"experimental\" when `circular` is False\n    and \"taylor\" (for now) when `circular` is True.\n    Defaults to \"default\" which means \"experimental\" when variable is not circular\n    and \"taylor\" when it is.\ncircular : bool, default False\n    If True, it interprets the values passed are from a circular variable measured in radians\n    and a circular KDE is used. Only valid for 1D KDE.\ngrid : tuple, optional\n    Number of rows and columns. Defaults to ``None``, the rows and columns are\n    automatically inferred. See :ref:`this section <common_grid>` for usage examples.\nfigsize : (float, float), optional\n    Figure size. If `None` it will be defined automatically.\ntextsize : float, optional\n    Text size scaling factor for labels, titles and lines. If `None` it will be autoscaled based\n    on `figsize`.\nlabeller : Labeller, optional\n    Class providing the method ``make_label_vert`` to generate the labels in the plot titles.\n    Read the :ref:`label_guide` for more details and usage examples.\nax : 2D array-like of matplotlib_axes or bokeh_figure, optional\n    A 2D array of locations into which to plot the densities. If not supplied, ArviZ will create\n    its own array of plot areas (and return it).\nbackend : {\"matplotlib\", \"bokeh\"}, default \"matplotlib\"\n    Select plotting backend.\nbackend_kwargs : dict, optional\n    These are kwargs specific to the backend being used, passed to\n    :func:`matplotlib.pyplot.subplots` or :class:`bokeh.plotting.figure`.\n    For additional documentation check the plotting method of the backend.\nshow : bool, optional\n    Call backend show function.\n\nReturns\n-------\naxes : 2D ndarray of matplotlib_axes or bokeh_figure\n\nSee Also\n--------\nplot_dist : Plot distribution as histogram or kernel density estimates.\nplot_posterior : Plot Posterior densities in the style of John K. Kruschke's book.\n\nExamples\n--------\nPlot default density plot\n\n.. plot::\n    :context: close-figs\n\n    >>> import arviz as az\n    >>> centered = az.load_arviz_data('centered_eight')\n    >>> non_centered = az.load_arviz_data('non_centered_eight')\n    >>> az.plot_density([centered, non_centered])\n\nPlot variables in a 4x5 grid\n\n.. plot::\n    :context: close-figs\n\n    >>> az.plot_density([centered, non_centered], grid=(4, 5))\n\nPlot subset variables by specifying variable name exactly\n\n.. plot::\n    :context: close-figs\n\n    >>> az.plot_density([centered, non_centered], var_names=[\"mu\"])\n\nPlot a specific `az.InferenceData` group\n\n.. plot::\n    :context: close-figs\n\n    >>> az.plot_density([centered, non_centered], var_names=[\"mu\"], group=\"prior\")\n\nSpecify highest density interval\n\n.. plot::\n    :context: close-figs\n\n    >>> az.plot_density([centered, non_centered], var_names=[\"mu\"], hdi_prob=.5)\n\nShade plots and/or remove outlines\n\n.. plot::\n    :context: close-figs\n\n    >>> az.plot_density([centered, non_centered], var_names=[\"mu\"], outline=False, shade=.8)\n\nSpecify binwidth for kernel density estimation\n\n.. plot::\n    :context: close-figs\n\n    >>> az.plot_density([centered, non_centered], var_names=[\"mu\"], bw=.9)\n\n\n\n\n\n\n\n","category":"method"},{"location":"api/plots/#ArviZPythonPlots.plot_dist-Tuple","page":"Plotting functions","title":"ArviZPythonPlots.plot_dist","text":"Plot distribution as histogram or kernel density estimates.\n\nBy default continuous variables are plotted using KDEs and discrete ones using histograms\n\nParameters\n----------\nvalues : array-like\n    Values to plot from an unknown continuous or discrete distribution.\nvalues2 : array-like, optional\n    Values to plot. If present, a 2D KDE or a hexbin will be estimated.\ncolor : string\n    valid matplotlib color.\nkind : string, default \"auto\"\n    By default (\"auto\") continuous variables will use the kind defined by rcParam\n    ``plot.density_kind`` and discrete ones will use histograms.\n    To override this use \"hist\" to plot histograms and \"kde\" for KDEs.\ncumulative : bool, default False\n    If true plot the estimated cumulative distribution function. Defaults to False.\n    Ignored for 2D KDE.\nlabel : string\n    Text to include as part of the legend.\nrotated : bool, default False\n    Whether to rotate the 1D KDE plot 90 degrees.\nrug : bool, default False\n    Add a `rug plot <https://en.wikipedia.org/wiki/Rug_plot>`_ for a specific subset\n    of values. Ignored for 2D KDE.\nbw : float or str, optional\n    If numeric, indicates the bandwidth and must be positive.\n    If str, indicates the method to estimate the bandwidth and must be\n    one of \"scott\", \"silverman\", \"isj\" or \"experimental\" when ``is_circular`` is False\n    and \"taylor\" (for now) when ``is_circular`` is True.\n    Defaults to \"experimental\" when variable is not circular and \"taylor\" when it is.\nquantiles : list, optional\n    Quantiles in ascending order used to segment the KDE. Use [.25, .5, .75] for quartiles.\ncontour : bool, default True\n    If True plot the 2D KDE using contours, otherwise plot a smooth 2D KDE.\nfill_last : bool, default True\n    If True fill the last contour of the 2D KDE plot.\nfigsize : (float, float), optional\n    Figure size. If `None` it will be defined automatically.\ntextsize : float, optional\n    Text size scaling factor for labels, titles and lines. If `None` it will be autoscaled based\n    on `figsize`. Not implemented for bokeh backend.\nplot_kwargs : dict\n    Keywords passed to the pdf line of a 1D KDE. Passed to :func:`arviz.plot_kde` as\n    ``plot_kwargs``.\nfill_kwargs : dict\n    Keywords passed to the fill under the line (use fill_kwargs={'alpha': 0} to disable fill).\n    Ignored for 2D KDE. Passed to :func:`arviz.plot_kde` as ``fill_kwargs``.\nrug_kwargs : dict\n    Keywords passed to the rug plot. Ignored if ``rug=False`` or for 2D KDE\n    Use ``space`` keyword (float) to control the position of the rugplot.\n    The larger this number the lower the rugplot. Passed to\n    :func:`arviz.plot_kde` as ``rug_kwargs``.\ncontour_kwargs : dict\n    Keywords passed to the contourplot. Ignored for 1D KDE.\ncontourf_kwargs : dict\n    Keywords passed to :meth:`matplotlib.axes.Axes.contourf`. Ignored for 1D KDE.\npcolormesh_kwargs : dict\n    Keywords passed to :meth:`matplotlib.axes.Axes.pcolormesh`. Ignored for 1D KDE.\nhist_kwargs : dict\n    Keyword arguments used to customize the histogram. Ignored when plotting a KDE.\n    They are passed to :meth:`matplotlib.axes.Axes.hist` if using matplotlib,\n    or to :meth:`bokeh.plotting.figure.quad` if using bokeh. In bokeh case,\n    the following extra keywords are also supported:\n\n    * ``color``: replaces the ``fill_color`` and ``line_color`` of the ``quad`` method\n    * ``bins``: taken from ``hist_kwargs`` and passed to :func:`numpy.histogram` instead\n    * ``density``: normalize histogram to represent a probability density function,\n      Defaults to ``True``\n\n    * ``cumulative``: plot the cumulative counts. Defaults to ``False``.\n\nis_circular : {False, True, \"radians\", \"degrees\"}, default False\n    Select input type {\"radians\", \"degrees\"} for circular histogram or KDE plot. If True,\n    default input type is \"radians\". When this argument is present, it interprets the\n    values passed are from a circular variable measured in radians and a circular KDE is\n    used. Inputs in \"degrees\" will undergo an internal conversion to radians. Only valid\n    for 1D KDE.\nax : matplotlib_axes or bokeh_figure, optional\n    Matplotlib or bokeh targets on which to plot. If not supplied, Arviz will create\n    its own plot area (and return it).\nbackend : {\"matplotlib\", \"bokeh\"}, default \"matplotlib\"\n    Select plotting backend.\nbackend_kwargs :dict, optional\n    These are kwargs specific to the backend being used, passed to\n    :func:`matplotlib.pyplot.subplots` or :class:`bokeh.plotting.figure`.\n    For additional documentation check the plotting method of the backend.\nshow : bool, optional\n    Call backend show function.\n\nReturns\n-------\naxes : matplotlib axes or bokeh figure\n\nSee Also\n--------\nplot_posterior : Plot Posterior densities in the style of John K. Kruschke's book.\nplot_density : Generate KDE plots for continuous variables and histograms for discrete ones.\nplot_kde : 1D or 2D KDE plot taking into account boundary conditions.\n\nExamples\n--------\nPlot an integer distribution\n\n.. plot::\n    :context: close-figs\n\n    >>> import numpy as np\n    >>> import arviz as az\n    >>> a = np.random.poisson(4, 1000)\n    >>> az.plot_dist(a)\n\nPlot a continuous distribution\n\n.. plot::\n    :context: close-figs\n\n    >>> b = np.random.normal(0, 1, 1000)\n    >>> az.plot_dist(b)\n\nAdd a rug under the Gaussian distribution\n\n.. plot::\n    :context: close-figs\n\n    >>> az.plot_dist(b, rug=True)\n\nSegment into quantiles\n\n.. plot::\n    :context: close-figs\n\n    >>> az.plot_dist(b, rug=True, quantiles=[.25, .5, .75])\n\nPlot as the cumulative distribution\n\n.. plot::\n    :context: close-figs\n\n    >>> az.plot_dist(b, rug=True, quantiles=[.25, .5, .75], cumulative=True)\n\n\n\n\n\n\n\n","category":"method"},{"location":"api/plots/#ArviZPythonPlots.plot_dist_comparison-Tuple","page":"Plotting functions","title":"ArviZPythonPlots.plot_dist_comparison","text":"Plot to compare fitted and unfitted distributions.\n\nThe resulting plots will show the compared distributions both on\nseparate axes (particularly useful when one of them is substantially tighter\nthan another), and plotted together, displaying a grid of three plots per\ndistribution.\n\nParameters\n----------\ndata : InferenceData\n    Any object that can be converted to an :class:`arviz.InferenceData` object\n    containing the posterior/prior data. Refer to documentation of\n    :func:`arviz.convert_to_dataset` for details.\nkind : {\"latent\", \"observed\"}, default \"latent\"\n    kind of plot to display The \"latent\" option includes {\"prior\", \"posterior\"},\n    and the \"observed\" option includes\n    {\"observed_data\", \"prior_predictive\", \"posterior_predictive\"}.\nfigsize : (float, float), optional\n    Figure size. If ``None`` it will be defined automatically.\ntextsize : float\n    Text size scaling factor for labels, titles and lines. If ``None`` it will be\n    autoscaled based on `figsize`.\nvar_names : str, list, list of lists, optional\n    if str, plot the variable. if list, plot all the variables in list\n    of all groups. if list of lists, plot the vars of groups in respective lists.\n    See :ref:`this section <common_var_names>` for usage examples.\ncoords : dict\n    Dictionary mapping dimensions to selected coordinates to be plotted.\n    Dimensions without a mapping specified will include all coordinates for\n    that dimension. See :ref:`this section <common_coords>` for usage examples.\ncombine_dims : set_like of str, optional\n    List of dimensions to reduce. Defaults to reducing only the \"chain\" and \"draw\" dimensions.\n    See :ref:`this section <common_combine_dims>` for usage examples.\ntransform : callable\n    Function to transform data (defaults to `None` i.e. the identity function).\nlegend : bool\n    Add legend to figure. By default True.\nlabeller : Labeller, optional\n    Class providing the method ``make_pp_label`` to generate the labels in the plot titles.\n    Read the :ref:`label_guide` for more details and usage examples.\nax : (nvars, 3) array-like of matplotlib_axes, optional\n    Matplotlib axes: The ax argument should have shape (nvars, 3), where the\n    last column is for the combined before/after plots and columns 0 and 1 are\n    for the before and after plots, respectively.\nprior_kwargs : dicts, optional\n    Additional keywords passed to :func:`arviz.plot_dist` for prior/predictive groups.\nposterior_kwargs : dicts, optional\n    Additional keywords passed to :func:`arviz.plot_dist` for posterior/predictive groups.\nobserved_kwargs : dicts, optional\n    Additional keywords passed to :func:`arviz.plot_dist` for observed_data group.\nbackend : {\"matplotlib\", \"bokeh\"}, default \"matplotlib\"\n    Select plotting backend.\nbackend_kwargs : dict, optional\n    These are kwargs specific to the backend being used, passed to\n    :func:`matplotlib.pyplot.subplots` or :class:`bokeh.plotting.figure`.\n    For additional documentation check the plotting method of the backend.\nshow : bool, optional\n    Call backend show function.\n\nReturns\n-------\naxes : 2D ndarray of matplotlib_axes\n    Returned object will have shape (nvars, 3),\n    where the last column is the combined plot and the first columns are the single plots.\n\nSee Also\n--------\nplot_bpv : Plot Bayesian p-value for observed data and Posterior/Prior predictive.\n\nExamples\n--------\nPlot the prior/posterior plot for specified vars and coords.\n\n.. plot::\n    :context: close-figs\n\n    >>> import arviz as az\n    >>> data = az.load_arviz_data('rugby')\n    >>> az.plot_dist_comparison(data, var_names=[\"defs\"], coords={\"team\" : [\"Italy\"]})\n\n\n\n\n\n\n\n\n","category":"method"},{"location":"api/plots/#ArviZPythonPlots.plot_dot-Tuple","page":"Plotting functions","title":"ArviZPythonPlots.plot_dot","text":"Plot distribution as dot plot or quantile dot plot.\n\nThis function uses the Wilkinson's Algorithm [1]_ to allot dots to bins.\nThe quantile dot plots was inspired from [2]_.\n\nParameters\n----------\nvalues : array-like\n    Values to plot from an unknown continuous or discrete distribution.\nbinwidth : float, optional\n    Width of the bin for drawing the dot plot.\ndotsize : float, default 1\n    The size of the dots relative to the bin width. The default makes dots be\n    just about as wide as the bin width.\nstackratio : float, default 1\n    The distance between the center of the dots in the same stack relative to the bin height.\n    The default makes dots in the same stack just touch each other.\npoint_interval : bool, default False\n    Plots the point interval. Uses ``hdi_prob`` to plot the HDI interval\npoint_estimate : str, optional\n    Plot point estimate per variable. Values should be ``mean``, ``median``, ``mode`` or None.\n    Defaults to ``auto`` i.e. it falls back to default set in rcParams.\ndotcolor : string, optional\n    The color of the dots. Should be a valid matplotlib color.\nintervalcolor : string, optional\n    The color of the interval. Should be a valid matplotlib color.\nlinewidth : int, default None\n    Line width throughout. If None it will be autoscaled based on `figsize`.\nmarkersize : int, default None\n    Markersize throughout. If None it will be autoscaled based on `figsize`.\nmarkercolor : string, optional\n    The color of the marker when plot_interval is True. Should be a valid matplotlib color.\nmarker : string, default \"o\"\n    The shape of the marker. Valid for matplotlib backend.\nhdi_prob : float, optional\n    Valid only when point_interval is True. Plots HDI for chosen percentage of density.\n    Defaults to ``stats.ci_prob`` rcParam. See :ref:`this section <common_hdi_prob>`\n    for usage examples.\nrotated : bool, default False\n    Whether to rotate the dot plot by 90 degrees.\nnquantiles : int, default 50\n    Number of quantiles to plot, used for quantile dot plots.\nquartiles : bool, default True\n    If True then the quartile interval will be plotted with the HDI.\nfigsize : (float,float), optional\n    Figure size. If ``None`` it will be defined automatically.\nplot_kwargs : dict, optional\n    Keywords passed for customizing the dots. Passed to :class:`mpl:matplotlib.patches.Circle`\n    in matplotlib and :meth:`bokeh.plotting.figure.circle` in bokeh.\nbackend :{\"matplotlib\", \"bokeh\"}, default \"matplotlib\"\n    Select plotting backend.\nax : axes, optional\n    Matplotlib_axes or bokeh_figure.\nshow : bool, optional\n    Call backend show function.\nbackend_kwargs : dict, optional\n    These are kwargs specific to the backend being used, passed to\n    :func:`matplotlib.pyplot.subplots` or :class:`bokeh.plotting.figure`.\n    For additional documentation check the plotting method of the backend.\n\nReturns\n-------\naxes : matplotlib_axes or bokeh_figure\n\nSee Also\n--------\nplot_dist : Plot distribution as histogram or kernel density estimates.\n\nReferences\n----------\n.. [1] Leland Wilkinson (1999) Dot Plots, The American Statistician, 53:3, 276-281,\n    DOI: 10.1080/00031305.1999.10474474\n.. [2] Matthew Kay, Tara Kola, Jessica R. Hullman,\n    and Sean A. Munson. 2016. When (ish) is My Bus? User-centered Visualizations of Uncertainty\n    in Everyday, Mobile Predictive Systems. DOI:https://doi.org/10.1145/2858036.2858558\n\nExamples\n--------\nPlot dot plot for a set of data points\n\n.. plot::\n    :context: close-figs\n\n    >>> import arviz as az\n    >>> import numpy as np\n    >>> values = np.random.normal(0, 1, 500)\n    >>> az.plot_dot(values)\n\nManually adjust number of quantiles to plot\n\n.. plot::\n    :context: close-figs\n\n    >>> az.plot_dot(values, nquantiles=100)\n\nAdd a point interval under the dot plot\n\n.. plot::\n    :context: close-figs\n\n    >>> az.plot_dot(values, point_interval=True)\n\nRotate the dot plots by 90 degrees i.e swap x and y axis\n\n.. plot::\n    :context: close-figs\n\n    >>> az.plot_dot(values, point_interval=True, rotated=True)\n\n\n\n\n\n\n\n\n","category":"method"},{"location":"api/plots/#ArviZPythonPlots.plot_ecdf-Tuple","page":"Plotting functions","title":"ArviZPythonPlots.plot_ecdf","text":"Plot ECDF or ECDF-Difference Plot with Confidence bands.\n\nPlots of the empirical cumulative distribution function (ECDF) of an array. Optionally, A `cdf`\nargument representing a reference CDF may be provided for comparison using a difference ECDF\nplot and/or confidence bands.\n\nAlternatively, the PIT for a single dataset may be visualized.\n\nNotes\n-----\nThis plot computes the confidence bands with the simulated based algorithm presented in [1]_.\n\nParameters\n----------\nvalues : array-like\n    Values to plot from an unknown continuous or discrete distribution.\nvalues2 : array-like, optional\n    values to compare to the original sample.\n\n    .. deprecated:: 0.18.0\n       Instead use ``cdf=scipy.stats.ecdf(values2).cdf.evaluate``.\ncdf : callable, optional\n    Cumulative distribution function of the distribution to compare the original sample.\n    The function must take as input a numpy array of draws from the distribution.\ndifference : bool, default False\n    If True then plot ECDF-difference plot otherwise ECDF plot.\nconfidence_bands : str or bool\n\n    - False: No confidence bands are plotted (default).\n    - True: Plot bands computed with the default algorithm (subject to change)\n    - \"pointwise\": Compute the pointwise (i.e. marginal) confidence band.\n    - \"optimized\": Use optimization to estimate a simultaneous confidence band.\n    - \"simulated\": Use Monte Carlo simulation to estimate a simultaneous confidence\n      band.\n\n    For simultaneous confidence bands to be correctly calibrated, provide `eval_points` that\n    are not dependent on the `values`.\nci_prob : float, default 0.94\n    The probability that the true ECDF lies within the confidence band. If `confidence_bands`\n    is \"pointwise\", this is the marginal probability instead of the joint probability.\neval_points : array-like, optional\n    The points at which to evaluate the ECDF. If None, `npoints` uniformly spaced points\n    between the data bounds will be used.\nrvs: callable, optional\n    A function that takes an integer `ndraws` and optionally the object passed to\n    `random_state` and returns an array of `ndraws` samples from the same distribution\n    as the original dataset. Required if `method` is \"simulated\" and variable is discrete.\nrandom_state : int, numpy.random.Generator or numpy.random.RandomState, optional\nnum_trials : int, default 500\n    The number of random ECDFs to generate for constructing simultaneous confidence bands\n    (if `confidence_bands` is \"simulated\").\nfigsize : (float,float), optional\n    Figure size. If `None` it will be defined automatically.\nfill_band : bool, default True\n    If True it fills in between to mark the area inside the confidence interval. Otherwise,\n    plot the border lines.\nplot_kwargs : dict, optional\n    Additional kwargs passed to :func:`mpl:matplotlib.pyplot.step` or\n    :meth:`bokeh.plotting.figure.step`\nfill_kwargs : dict, optional\n    Additional kwargs passed to :func:`mpl:matplotlib.pyplot.fill_between` or\n    :meth:`bokeh:bokeh.plotting.Figure.varea`\nplot_outline_kwargs : dict, optional\n    Additional kwargs passed to :meth:`mpl:matplotlib.axes.Axes.plot` or\n    :meth:`bokeh:bokeh.plotting.Figure.line`\nax :axes, optional\n    Matplotlib axes or bokeh figures.\nshow : bool, optional\n    Call backend show function.\nbackend : {\"matplotlib\", \"bokeh\"}, default \"matplotlib\"\n    Select plotting backend.\nbackend_kwargs : dict, optional\n    These are kwargs specific to the backend being used, passed to\n    :func:`matplotlib.pyplot.subplots` or :class:`bokeh.plotting.figure`.\n    For additional documentation check the plotting method of the backend.\nnpoints : int, default 100\n    The number of evaluation points for the ecdf or ecdf-difference plots, if `eval_points` is\n    not provided or `pit` is `True`.\n\n    .. deprecated:: 0.18.0\n       Instead specify ``eval_points=np.linspace(np.min(values), np.max(values), npoints)``\n       unless `pit` is `True`.\npointwise : bool, default False\n\n    .. deprecated:: 0.18.0\n       Instead use `confidence_bands=\"pointwise\"`.\nfpr : float, optional\n\n    .. deprecated:: 0.18.0\n       Instead use `ci_prob=1-fpr`.\npit : bool, default False\n    If True plots the ECDF or ECDF-diff of PIT of sample.\n\n    .. deprecated:: 0.18.0\n       See below example instead.\n\nReturns\n-------\naxes : matplotlib_axes or bokeh_figure\n\nReferences\n----------\n.. [1] Säilynoja, T., Bürkner, P.C. and Vehtari, A. (2022). Graphical Test for\n    Discrete Uniformity and its Applications in Goodness of Fit Evaluation and\n    Multiple Sample Comparison. Statistics and Computing, 32(32).\n\nExamples\n--------\nIn a future release, the default behaviour of ``plot_ecdf`` will change.\nTo maintain the original behaviour you should do:\n\n.. plot::\n    :context: close-figs\n\n    >>> import arviz as az\n    >>> import numpy as np\n    >>> from scipy.stats import uniform, norm\n    >>>\n    >>> sample = norm(0,1).rvs(1000)\n    >>> npoints = 100\n    >>> az.plot_ecdf(sample, eval_points=np.linspace(sample.min(), sample.max(), npoints))\n\nHowever, seeing this warning isn't an indicator of anything being wrong,\nif you are happy to get different behaviour as ArviZ improves and adds\nnew algorithms you can ignore it like so:\n\n.. plot::\n    :context: close-figs\n\n    >>> import warnings\n    >>> warnings.filterwarnings(\"ignore\", category=az.utils.BehaviourChangeWarning)\n\nPlot an ECDF plot for a given sample evaluated at the sample points. This will become\nthe new behaviour when `eval_points` is not provided:\n\n.. plot::\n    :context: close-figs\n\n    >>> az.plot_ecdf(sample, eval_points=np.unique(sample))\n\nPlot an ECDF plot with confidence bands for comparing a given sample to a given distribution.\nWe manually specify evaluation points independent of the values so that the confidence bands\nare correctly calibrated.\n\n.. plot::\n    :context: close-figs\n\n    >>> distribution = norm(0,1)\n    >>> eval_points = np.linspace(*distribution.ppf([0.001, 0.999]), 100)\n    >>> az.plot_ecdf(\n    >>>     sample, eval_points=eval_points,\n    >>>     cdf=distribution.cdf, confidence_bands=True\n    >>> )\n\nPlot an ECDF-difference plot with confidence bands for comparing a given sample\nto a given distribution.\n\n.. plot::\n    :context: close-figs\n\n    >>> az.plot_ecdf(\n    >>>     sample, cdf=distribution.cdf,\n    >>>     confidence_bands=True, difference=True\n    >>> )\n\nPlot an ECDF plot with confidence bands for the probability integral transform (PIT) of a\ncontinuous sample. If drawn from the reference distribution, the PIT values should be uniformly\ndistributed.\n\n.. plot::\n    :context: close-figs\n\n    >>> pit_vals = distribution.cdf(sample)\n    >>> uniform_dist = uniform(0, 1)\n    >>> az.plot_ecdf(\n    >>>     pit_vals, cdf=uniform_dist.cdf, confidence_bands=True,\n    >>> )\n\nPlot an ECDF-difference plot of PIT values.\n\n.. plot::\n    :context: close-figs\n\n    >>> az.plot_ecdf(\n    >>>     pit_vals, cdf = uniform_dist.cdf, confidence_bands = True,\n    >>>     difference = True\n    >>> )\n\n\n\n\n\n\n\n","category":"method"},{"location":"api/plots/#ArviZPythonPlots.plot_elpd-Tuple","page":"Plotting functions","title":"ArviZPythonPlots.plot_elpd","text":"Plot pointwise elpd differences between two or more models.\n\nPointwise model comparison based on their expected log pointwise predictive density (ELPD).\n\nNotes\n-----\nThe ELPD is estimated either by Pareto smoothed importance sampling leave-one-out\ncross-validation (LOO) or using the widely applicable information criterion (WAIC).\nWe recommend LOO in line with the work presented by [1]_.\n\nParameters\n----------\ncompare_dict : mapping of {str : ELPDData or InferenceData}\n    A dictionary mapping the model name to the object containing inference data or the result\n    of :func:`arviz.loo` or :func:`arviz.waic` functions.\n    Refer to :func:`arviz.convert_to_inference_data` for details on possible dict items.\ncolor : str or array_like, default \"C0\"\n    Colors of the scatter plot. If color is a str all dots will have the same color.\n    If it is the size of the observations, each dot will have the specified color.\n    Otherwise, it will be interpreted as a list of the dims to be used for the color code.\nxlabels : bool, default False\n    Use coords as xticklabels.\nfigsize : (float, float), optional\n    If `None`, size is (8 + numvars, 8 + numvars).\ntextsize : float, optional\n    Text size for labels. If `None` it will be autoscaled based on `figsize`.\ncoords : mapping, optional\n    Coordinates of points to plot. **All** values are used for computation, but only a\n    subset can be plotted for convenience. See :ref:`this section <common_coords>`\n    for usage examples.\nlegend : bool, default False\n    Include a legend to the plot. Only taken into account when color argument is a dim name.\nthreshold : float, optional\n    If some elpd difference is larger than ``threshold * elpd.std()``, show its label. If\n    `None`, no observations will be highlighted.\nic : str, optional\n    Information Criterion (\"loo\" for PSIS-LOO, \"waic\" for WAIC) used to compare models.\n    Defaults to ``rcParams[\"stats.information_criterion\"]``.\n    Only taken into account when input is :class:`arviz.InferenceData`.\nscale : str, optional\n    Scale argument passed to :func:`arviz.loo` or :func:`arviz.waic`, see their docs for\n    details. Only taken into account when values in ``compare_dict`` are\n    :class:`arviz.InferenceData`.\nvar_name : str, optional\n    Argument passed to to :func:`arviz.loo` or :func:`arviz.waic`, see their docs for\n    details. Only taken into account when values in ``compare_dict`` are\n    :class:`arviz.InferenceData`.\nplot_kwargs : dicts, optional\n    Additional keywords passed to :meth:`matplotlib.axes.Axes.scatter`.\nax : axes, optional\n    :class:`matplotlib.axes.Axes` or :class:`bokeh.plotting.Figure`.\nbackend : {\"matplotlib\", \"bokeh\"}, default \"matplotlib\"\n    Select plotting backend.\nbackend_kwargs : dict, optional\n    These are kwargs specific to the backend being used, passed to\n    :func:`matplotlib.pyplot.subplots` or :class:`bokeh.plotting.figure`.\n    For additional documentation check the plotting method of the backend.\nshow : bool, optional\n    Call backend show function.\n\nReturns\n-------\naxes : matplotlib_axes or bokeh_figure\n\nSee Also\n--------\nplot_compare : Summary plot for model comparison.\nloo : Compute Pareto-smoothed importance sampling leave-one-out cross-validation (PSIS-LOO-CV).\nwaic : Compute the widely applicable information criterion.\n\nReferences\n----------\n.. [1] Vehtari et al. (2016). Practical Bayesian model evaluation using leave-one-out\n   cross-validation and WAIC https://arxiv.org/abs/1507.04544\n\nExamples\n--------\nCompare pointwise PSIS-LOO for centered and non centered models of the 8-schools problem\nusing matplotlib.\n\n.. plot::\n    :context: close-figs\n\n    >>> import arviz as az\n    >>> idata1 = az.load_arviz_data(\"centered_eight\")\n    >>> idata2 = az.load_arviz_data(\"non_centered_eight\")\n    >>> az.plot_elpd(\n    >>>     {\"centered model\": idata1, \"non centered model\": idata2},\n    >>>     xlabels=True\n    >>> )\n\n.. bokeh-plot::\n    :source-position: above\n\n    import arviz as az\n    idata1 = az.load_arviz_data(\"centered_eight\")\n    idata2 = az.load_arviz_data(\"non_centered_eight\")\n    az.plot_elpd(\n        {\"centered model\": idata1, \"non centered model\": idata2},\n        backend=\"bokeh\"\n    )\n\n\n\n\n\n\n\n\n","category":"method"},{"location":"api/plots/#ArviZPythonPlots.plot_energy-Tuple","page":"Plotting functions","title":"ArviZPythonPlots.plot_energy","text":"Plot energy transition distribution and marginal energy distribution in HMC algorithms.\n\nThis may help to diagnose poor exploration by gradient-based algorithms like HMC or NUTS.\nThe energy function in HMC can identify posteriors with heavy tailed distributions, that\nin practice are challenging for sampling.\n\nThis plot is in the style of the one used in [1]_.\n\nParameters\n----------\ndata : obj\n    :class:`xarray.Dataset`, or any object that can be converted (must represent\n    ``sample_stats`` and have an ``energy`` variable).\nkind : str, optional\n    Type of plot to display (\"kde\", \"hist\").\nbfmi : bool, default True\n    If True add to the plot the value of the estimated Bayesian fraction of missing\n    information.\nfigsize : (float, float), optional\n    Figure size. If `None` it will be defined automatically.\nlegend : bool, default True\n    Flag for plotting legend.\nfill_alpha : tuple, default (1, 0.75)\n    Alpha blending value for the shaded area under the curve, between 0\n    (no shade) and 1 (opaque).\nfill_color : tuple of valid matplotlib color, default ('C0', 'C5')\n    Color for Marginal energy distribution and Energy transition distribution.\nbw : float or str, optional\n    If numeric, indicates the bandwidth and must be positive.\n    If str, indicates the method to estimate the bandwidth and must be\n    one of \"scott\", \"silverman\", \"isj\" or \"experimental\". Defaults to \"experimental\".\n    Only works if ``kind='kde'``.\ntextsize : float, optional\n    Text size scaling factor for labels, titles and lines. If `None` it will be autoscaled\n    based on `figsize`.\nfill_kwargs : dicts, optional\n    Additional keywords passed to :func:`arviz.plot_kde` (to control the shade).\nplot_kwargs : dicts, optional\n    Additional keywords passed to :func:`arviz.plot_kde` or :func:`matplotlib.pyplot.hist`\n    (if ``type='hist'``).\nax : axes, optional\n    :class:`matplotlib.axes.Axes` or :class:`bokeh.plotting.Figure`.\nbackend : {\"matplotlib\", \"bokeh\"}, default \"matplotlib\"\n    Select plotting backend.\nbackend_kwargs : dict, optional\n    These are kwargs specific to the backend being used, passed to\n    :func:`matplotlib.pyplot.subplots` or :class:`bokeh.plotting.figure`.\n    For additional documentation check the plotting method of the backend.\nshow : bool, optional\n    Call backend show function.\n\nReturns\n-------\naxes : matplotlib axes or bokeh figures\n\nSee Also\n--------\nbfmi : Calculate the estimated Bayesian fraction of missing information (BFMI).\n\nReferences\n----------\n.. [1] Betancourt (2016). Diagnosing Suboptimal Cotangent Disintegrations in\nHamiltonian Monte Carlo https://arxiv.org/abs/1604.00695\n\nExamples\n--------\nPlot a default energy plot\n\n.. plot::\n    :context: close-figs\n\n    >>> import arviz as az\n    >>> data = az.load_arviz_data('centered_eight')\n    >>> az.plot_energy(data)\n\nRepresent energy plot via histograms\n\n.. plot::\n    :context: close-figs\n\n    >>> az.plot_energy(data, kind='hist')\n\n\n\n\n\n\n\n\n","category":"method"},{"location":"api/plots/#ArviZPythonPlots.plot_ess-Tuple","page":"Plotting functions","title":"ArviZPythonPlots.plot_ess","text":"Generate quantile, local, or evolution ESS plots.\n\nThe local and the quantile ESS plots are recommended for checking\nthat there are enough samples for all the explored regions of the\nparameter space. Checking local and quantile ESS is particularly\nrelevant when working with HDI intervals as opposed to ESS bulk,\nwhich is suitable for point estimates.\n\nParameters\n----------\nidata : InferenceData\n    Any object that can be converted to an :class:`arviz.InferenceData` object\n    Refer to documentation of :func:`arviz.convert_to_dataset` for details.\nvar_names : list of str, optional\n    Variables to be plotted. Prefix the variables by ``~`` when you want to exclude\n    them from the plot. See :ref:`this section <common_var_names>` for usage examples.\nfilter_vars : {None, \"like\", \"regex\"}, default None\n    If `None` (default), interpret `var_names` as the real variables names. If \"like\",\n    interpret `var_names` as substrings of the real variables names. If \"regex\",\n    interpret `var_names` as regular expressions on the real variables names. See\n    :ref:`this section <common_filter_vars>` for usage examples.\nkind : {\"local\", \"quantile\", \"evolution\"}, default \"local\"\n    Specify the kind of plot:\n\n    * The ``kind=\"local\"`` argument generates the ESS' local efficiency for\n      estimating quantiles of a desired posterior.\n    * The ``kind=\"quantile\"`` argument generates the ESS' local efficiency\n      for estimating small-interval probability of a desired posterior.\n    * The ``kind=\"evolution\"`` argument generates the estimated ESS'\n      with incrised number of iterations of a desired posterior.\n\nrelative : bool, default False\n    Show relative ess in plot ``ress = ess / N``.\ncoords : dict, optional\n    Coordinates of `var_names` to be plotted. Passed to :meth:`xarray.Dataset.sel`.\n    See :ref:`this section <common_coords>` for usage examples.\ngrid : tuple, optional\n    Number of rows and columns. By default, the rows and columns are\n    automatically inferred. See :ref:`this section <common_grid>` for usage examples.\nfigsize : (float, float), optional\n    Figure size. If ``None`` it will be defined automatically.\ntextsize : float, optional\n    Text size scaling factor for labels, titles and lines. If ``None`` it will be autoscaled\n    based on `figsize`.\nrug : bool, default False\n    Add a `rug plot <https://en.wikipedia.org/wiki/Rug_plot>`_ for a specific subset of values.\nrug_kind : str, default \"diverging\"\n    Variable in sample stats to use as rug mask. Must be a boolean variable.\nn_points : int, default 20\n    Number of points for which to plot their quantile/local ess or number of subsets\n    in the evolution plot.\nextra_methods : bool, default False\n    Plot mean and sd ESS as horizontal lines. Not taken into account if ``kind = 'evolution'``.\nmin_ess : int, default 400\n    Minimum number of ESS desired. If ``relative=True`` the line is plotted at\n    ``min_ess / n_samples`` for local and quantile kinds and as a curve following\n    the ``min_ess / n`` dependency in evolution kind.\nlabeller : Labeller, optional\n    Class providing the method ``make_label_vert`` to generate the labels in the plot titles.\n    Read the :ref:`label_guide` for more details and usage examples.\nax : 2D array-like of matplotlib_axes or bokeh_figure, optional\n    A 2D array of locations into which to plot the densities. If not supplied, ArviZ will create\n    its own array of plot areas (and return it).\nextra_kwargs : dict, optional\n    If evolution plot, `extra_kwargs` is used to plot ess tail and differentiate it\n    from ess bulk. Otherwise, passed to extra methods lines.\ntext_kwargs : dict, optional\n    Only taken into account when ``extra_methods=True``. kwargs passed to ax.annotate\n    for extra methods lines labels. It accepts the additional\n    key ``x`` to set ``xy=(text_kwargs[\"x\"], mcse)``\nhline_kwargs : dict, optional\n    kwargs passed to :func:`~matplotlib.axes.Axes.axhline` or to :class:`~bokeh.models.Span`\n    depending on the backend for the horizontal minimum ESS line.\n    For relative ess evolution plots the kwargs are passed to\n    :func:`~matplotlib.axes.Axes.plot` or to :class:`~bokeh.plotting.figure.line`\nrug_kwargs : dict\n    kwargs passed to rug plot.\nbackend : {\"matplotlib\", \"bokeh\"}, default \"matplotlib\"\n    Select plotting backend.\nbackend_kwargs : dict, optional\n    These are kwargs specific to the backend being used, passed to\n    :func:`matplotlib.pyplot.subplots` or :class:`bokeh.plotting.figure`.\n    For additional documentation check the plotting method of the backend.\nshow : bool, optional\n    Call backend show function.\n**kwargs\n    Passed as-is to :meth:`mpl:matplotlib.axes.Axes.hist` or\n    :meth:`mpl:matplotlib.axes.Axes.plot` function depending on the\n    value of `kind`.\n\nReturns\n-------\naxes : matplotlib_axes or bokeh_figure\n\nSee Also\n--------\ness : Calculate estimate of the effective sample size.\n\nReferences\n----------\n.. [1] Vehtari et al. (2021). Rank-normalization, folding, and\n    localization: An improved Rhat for assessing convergence of\n    MCMC. Bayesian analysis, 16(2):667-718.\n\nExamples\n--------\nPlot local ESS.\n\n.. plot::\n    :context: close-figs\n\n    >>> import arviz as az\n    >>> idata = az.load_arviz_data(\"centered_eight\")\n    >>> coords = {\"school\": [\"Choate\", \"Lawrenceville\"]}\n    >>> az.plot_ess(\n    ...     idata, kind=\"local\", var_names=[\"mu\", \"theta\"], coords=coords\n    ... )\n\nPlot ESS evolution as the number of samples increase. When the model is converging properly,\nboth lines in this plot should be roughly linear.\n\n.. plot::\n    :context: close-figs\n\n    >>> az.plot_ess(\n    ...     idata, kind=\"evolution\", var_names=[\"mu\", \"theta\"], coords=coords\n    ... )\n\nCustomize local ESS plot to look like reference paper.\n\n.. plot::\n    :context: close-figs\n\n    >>> az.plot_ess(\n    ...     idata, kind=\"local\", var_names=[\"mu\"], drawstyle=\"steps-mid\", color=\"k\",\n    ...     linestyle=\"-\", marker=None, rug=True, rug_kwargs={\"color\": \"r\"}\n    ... )\n\nCustomize ESS evolution plot to look like reference paper.\n\n.. plot::\n    :context: close-figs\n\n    >>> extra_kwargs = {\"color\": \"lightsteelblue\"}\n    >>> az.plot_ess(\n    ...     idata, kind=\"evolution\", var_names=[\"mu\"],\n    ...     color=\"royalblue\", extra_kwargs=extra_kwargs\n    ... )\n\n\n\n\n\n\n\n\n","category":"method"},{"location":"api/plots/#ArviZPythonPlots.plot_forest-Tuple","page":"Plotting functions","title":"ArviZPythonPlots.plot_forest","text":"Forest plot to compare HDI intervals from a number of distributions.\n\nGenerate forest or ridge plots to compare distributions from a model or list of models.\nAdditionally, the function can display effective sample sizes (ess) and Rhats to visualize\nconvergence diagnostics alongside the distributions.\n\nParameters\n----------\ndata : InferenceData\n    Any object that can be converted to an :class:`arviz.InferenceData` object\n    Refer to documentation of :func:`arviz.convert_to_dataset` for details.\nkind : {\"foresplot\", \"ridgeplot\"}, default \"forestplot\"\n    Specify the kind of plot:\n\n    * The ``kind=\"forestplot\"`` generates credible intervals, where the central points are the\n      estimated posterior median, the thick lines are the central quartiles, and the thin lines\n      represent the :math:`100\\times(hdi\\_prob)\\%` highest density intervals.\n    * The ``kind=\"ridgeplot\"`` option generates density plots (kernel density estimate or\n      histograms) in the same graph. Ridge plots can be configured to have different overlap,\n      truncation bounds and quantile markers.\n\nmodel_names : list of str, optional\n    List with names for the models in the list of data. Useful when plotting more that one\n    dataset.\nvar_names : list of str, optional\n    Variables to be plotted. Prefix the variables by ``~`` when you want to exclude\n    them from the plot. See :ref:`this section <common_var_names>` for usage examples.\ncombine_dims : set_like of str, optional\n    List of dimensions to reduce. Defaults to reducing only the \"chain\" and \"draw\" dimensions.\n    See :ref:`this section <common_combine_dims>` for usage examples.\nfilter_vars : {None, \"like\", \"regex\"}, default None\n    If `None` (default), interpret `var_names` as the real variables names. If \"like\",\n    interpret `var_names` as substrings of the real variables names. If \"regex\",\n    interpret `var_names` as regular expressions on the real variables names. See\n    :ref:`this section <common_filter_vars>` for usage examples.\ntransform : callable, optional\n    Function to transform data (defaults to None i.e.the identity function).\ncoords : dict, optional\n    Coordinates of ``var_names`` to be plotted. Passed to :meth:`xarray.Dataset.sel`.\n    See :ref:`this section <common_coords>` for usage examples.\ncombined : bool, default False\n    Flag for combining multiple chains into a single chain. If False, chains will\n    be plotted separately. See :ref:`this section <common_combine>` for usage examples.\nhdi_prob : float, default 0.94\n    Plots highest posterior density interval for chosen percentage of density.\n    See :ref:`this section <common_ hdi_prob>` for usage examples.\nrope : list, tuple or dictionary of {str : tuples or lists}, optional\n    A dictionary of tuples with the lower and upper values of the Region Of Practical\n    Equivalence. See :ref:`this section <common_rope>` for usage examples.\nquartiles : bool, default True\n    Flag for plotting the interquartile range, in addition to the ``hdi_prob`` intervals.\nr_hat : bool, default False\n    Flag for plotting Split R-hat statistics. Requires 2 or more chains.\ness : bool, default False\n    Flag for plotting the effective sample size.\ncolors : list or string, optional\n    list with valid matplotlib colors, one color per model. Alternative a string can be passed.\n    If the string is `cycle`, it will automatically chose a color per model from the matplotlibs\n    cycle. If a single color is passed, eg 'k', 'C2', 'red' this color will be used for all\n    models. Defaults to 'cycle'.\ntextsize : float, optional\n    Text size scaling factor for labels, titles and lines. If `None` it will be autoscaled based\n    on ``figsize``.\nlinewidth : int, optional\n    Line width throughout. If `None` it will be autoscaled based on ``figsize``.\nmarkersize : int, optional\n    Markersize throughout. If `None` it will be autoscaled based on ``figsize``.\nlegend : bool, optional\n    Show a legend with the color encoded model information.\n    Defaults to True, if there are multiple models.\nlabeller : Labeller, optional\n    Class providing the method ``make_label_vert`` to generate the labels in the plot titles.\n    Read the :ref:`label_guide` for more details and usage examples.\nridgeplot_alpha: float, optional\n    Transparency for ridgeplot fill.  If ``ridgeplot_alpha=0``, border is colored by model,\n    otherwise a `black` outline is used.\nridgeplot_overlap : float, default 2\n    Overlap height for ridgeplots.\nridgeplot_kind : string, optional\n    By default (\"auto\") continuous variables are plotted using KDEs and discrete ones using\n    histograms. To override this use \"hist\" to plot histograms and \"density\" for KDEs.\nridgeplot_truncate : bool, default True\n    Whether to truncate densities according to the value of ``hdi_prob``.\nridgeplot_quantiles : list, optional\n    Quantiles in ascending order used to segment the KDE. Use [.25, .5, .75] for quartiles.\nfigsize : (float, float), optional\n    Figure size. If `None`, it will be defined automatically.\nax : axes, optional\n    :class:`matplotlib.axes.Axes` or :class:`bokeh.plotting.Figure`.\nbackend : {\"matplotlib\", \"bokeh\"}, default \"matplotlib\"\n    Select plotting backend.\nbackend_config : dict, optional\n    Currently specifies the bounds to use for bokeh axes. Defaults to value set in ``rcParams``.\nbackend_kwargs : dict, optional\n    These are kwargs specific to the backend being used, passed to\n    :func:`matplotlib.pyplot.subplots` or :class:`bokeh.plotting.figure`.\n    For additional documentation check the plotting method of the backend.\nshow : bool, optional\n    Call backend show function.\n\nReturns\n-------\n1D ndarray of matplotlib_axes or bokeh_figures\n\nSee Also\n--------\nplot_posterior : Plot Posterior densities in the style of John K. Kruschke's book.\nplot_density : Generate KDE plots for continuous variables and histograms for discrete ones.\nsummary : Create a data frame with summary statistics.\n\nExamples\n--------\nForestplot\n\n.. plot::\n    :context: close-figs\n\n    >>> import arviz as az\n    >>> non_centered_data = az.load_arviz_data('non_centered_eight')\n    >>> axes = az.plot_forest(non_centered_data,\n    >>>                            kind='forestplot',\n    >>>                            var_names=[\"^the\"],\n    >>>                            filter_vars=\"regex\",\n    >>>                            combined=True,\n    >>>                            figsize=(9, 7))\n    >>> axes[0].set_title('Estimated theta for 8 schools model')\n\nForestplot with multiple datasets\n\n.. plot::\n    :context: close-figs\n\n    >>> centered_data = az.load_arviz_data('centered_eight')\n    >>> axes = az.plot_forest([non_centered_data, centered_data],\n    >>>                            model_names = [\"non centered eight\", \"centered eight\"],\n    >>>                            kind='forestplot',\n    >>>                            var_names=[\"^the\"],\n    >>>                            filter_vars=\"regex\",\n    >>>                            combined=True,\n    >>>                            figsize=(9, 7))\n    >>> axes[0].set_title('Estimated theta for 8 schools models')\n\nRidgeplot\n\n.. plot::\n    :context: close-figs\n\n    >>> axes = az.plot_forest(non_centered_data,\n    >>>                            kind='ridgeplot',\n    >>>                            var_names=['theta'],\n    >>>                            combined=True,\n    >>>                            ridgeplot_overlap=3,\n    >>>                            colors='white',\n    >>>                            figsize=(9, 7))\n    >>> axes[0].set_title('Estimated theta for 8 schools model')\n\nRidgeplot non-truncated and with quantiles\n\n.. plot::\n    :context: close-figs\n\n    >>> axes = az.plot_forest(non_centered_data,\n    >>>                            kind='ridgeplot',\n    >>>                            var_names=['theta'],\n    >>>                            combined=True,\n    >>>                            ridgeplot_truncate=False,\n    >>>                            ridgeplot_quantiles=[.25, .5, .75],\n    >>>                            ridgeplot_overlap=0.7,\n    >>>                            colors='white',\n    >>>                            figsize=(9, 7))\n    >>> axes[0].set_title('Estimated theta for 8 schools model')\n\n\n\n\n\n\n\n","category":"method"},{"location":"api/plots/#ArviZPythonPlots.plot_hdi-Tuple","page":"Plotting functions","title":"ArviZPythonPlots.plot_hdi","text":"Plot HDI intervals for regression data.\n\nParameters\n----------\nx : array-like\n    Values to plot.\ny : array-like, optional\n    Values from which to compute the HDI. Assumed shape ``(chain, draw, \\*shape)``.\n    Only optional if ``hdi_data`` is present.\nhdi_data : array_like, optional\n    Precomputed HDI values to use. Assumed shape is ``(*x.shape, 2)``.\nhdi_prob : float, optional\n    Probability for the highest density interval. Defaults to ``stats.ci_prob`` rcParam.\n    See :ref:`this section <common_ hdi_prob>` for usage examples.\ncolor : str, default \"C1\"\n    Color used for the limits of the HDI and fill. Should be a valid matplotlib color.\ncircular : bool, default False\n    Whether to compute the HDI taking into account ``x`` is a circular variable\n    (in the range [-np.pi, np.pi]) or not. Defaults to False (i.e non-circular variables).\nsmooth : boolean, default True\n    If True the result will be smoothed by first computing a linear interpolation of the data\n    over a regular grid and then applying the Savitzky-Golay filter to the interpolated data.\nsmooth_kwargs : dict, optional\n    Additional keywords modifying the Savitzky-Golay filter. See\n    :func:`scipy:scipy.signal.savgol_filter` for details.\nfigsize : (float, float), optional\n    Figure size. If ``None``, it will be defined automatically.\nfill_kwargs : dict, optional\n    Keywords passed to :meth:`mpl:matplotlib.axes.Axes.fill_between`\n    (use ``fill_kwargs={'alpha': 0}`` to disable fill) or to\n    :meth:`bokeh.plotting.Figure.patch`.\nplot_kwargs : dict, optional\n    HDI limits keyword arguments, passed to :meth:`mpl:matplotlib.axes.Axes.plot` or\n    :meth:`bokeh.plotting.Figure.patch`.\nhdi_kwargs : dict, optional\n    Keyword arguments passed to :func:`~arviz.hdi`. Ignored if ``hdi_data`` is present.\nax : axes, optional\n    Matplotlib axes or bokeh figures.\nbackend : {\"matplotlib\", \"bokeh\"}, default \"matplotlib\"\n    Select plotting backend.\nbackend_kwargs : dict, optional\n    These are kwargs specific to the backend being used, passed to\n    :func:`matplotlib.pyplot.subplots` or :class:`bokeh.plotting.figure`.\n    For additional documentation check the plotting method of the backend.\nshow : bool, optional\n    Call backend show function.\n\nReturns\n-------\naxes : matplotlib axes or bokeh figures\n\nSee Also\n--------\nhdi : Calculate highest density interval (HDI) of array for given probability.\n\nExamples\n--------\nPlot HDI interval of simulated random-walk data using `y` argument:\n\n.. plot::\n    :context: close-figs\n\n    >>> import numpy as np\n    >>> import arviz as az\n    >>> # time-steps random walk\n    >>> x_data =np.arange(0,100)\n    >>> # Mean random walk\n    >>> mu = np.zeros(100)\n    >>> for i in x_data: mu[i] = mu[i-1] + np.random.normal(0, 1, 1)\n    >>> # Simulated pp samples form the random walk time series\n    >>> y_data = np.random.normal(2 + mu * 0.5, 0.5, size = (2, 50, 100))\n    >>> az.plot_hdi(x_data, y_data)\n\n``plot_hdi`` can also be given precalculated values with the argument ``hdi_data``. This example\nshows how to use :func:`~arviz.hdi` to precalculate the values and pass these values to\n``plot_hdi``. Similarly to an example in ``hdi`` we are using the ``input_core_dims``\nargument of :func:`~arviz.wrap_xarray_ufunc` to manually define the dimensions over which\nto calculate the HDI.\n\n.. plot::\n    :context: close-figs\n\n    >>> hdi_data = az.hdi(y_data, input_core_dims=[[\"draw\"]])\n    >>> ax = az.plot_hdi(x_data, hdi_data=hdi_data[0], color=\"r\", fill_kwargs={\"alpha\": .2})\n    >>> az.plot_hdi(x_data, hdi_data=hdi_data[1], color=\"k\", ax=ax, fill_kwargs={\"alpha\": .2})\n\n``plot_hdi`` can also be used with Inference Data objects. Here we use the posterior predictive\nto plot the HDI interval.\n\n.. plot::\n    :context: close-figs\n\n    >>> X = np.random.normal(0,1,100)\n    >>> Y = np.random.normal(2 + X * 0.5, 0.5, size=(2,10,100))\n    >>> idata = az.from_dict(posterior={\"y\": Y}, constant_data={\"x\":X})\n    >>> x_data = idata.constant_data.x\n    >>> y_data = idata.posterior.y\n    >>> az.plot_hdi(x_data, y_data)\n\n\n\n\n\n\n\n\n","category":"method"},{"location":"api/plots/#ArviZPythonPlots.plot_kde-Tuple","page":"Plotting functions","title":"ArviZPythonPlots.plot_kde","text":"1D or 2D KDE plot taking into account boundary conditions.\n\nParameters\n----------\nvalues : array-like\n    Values to plot\nvalues2 : array-like, optional\n    Values to plot. If present, a 2D KDE will be estimated\ncumulative : bool, dafault False\n    If True plot the estimated cumulative distribution function. Ignored for 2D KDE.\nrug : bool, default False\n    Add a `rug plot <https://en.wikipedia.org/wiki/Rug_plot>`_ for a specific subset of\n    values. Ignored for 2D KDE.\nlabel : string, optional\n    Text to include as part of the legend.\nbw : float or str, optional\n    If numeric, indicates the bandwidth and must be positive.\n    If str, indicates the method to estimate the bandwidth and must be\n    one of \"scott\", \"silverman\", \"isj\" or \"experimental\" when ``is_circular`` is False\n    and \"taylor\" (for now) when ``is_circular`` is True.\n    Defaults to \"default\" which means \"experimental\" when variable is not circular\n    and \"taylor\" when it is.\nadaptive : bool, default False\n    If True, an adaptative bandwidth is used. Only valid for 1D KDE.\nquantiles : list, optional\n    Quantiles in ascending order used to segment the KDE. Use [.25, .5, .75] for quartiles.\nrotated : bool, default False\n    Whether to rotate the 1D KDE plot 90 degrees.\ncontour : bool, default True\n    If True plot the 2D KDE using contours, otherwise plot a smooth 2D KDE.\nhdi_probs : list, optional\n    Plots highest density credibility regions for the provided probabilities for a 2D KDE.\n    Defaults to [0.5, 0.8, 0.94].\nfill_last : bool, default False\n    If True fill the last contour of the 2D KDE plot.\nfigsize : (float, float), optional\n    Figure size. If ``None`` it will be defined automatically.\ntextsize : float, optional\n    Text size scaling factor for labels, titles and lines. If ``None`` it will be autoscaled\n    based on ``figsize``. Not implemented for bokeh backend.\nplot_kwargs : dict, optional\n    Keywords passed to the pdf line of a 1D KDE. See :meth:`mpl:matplotlib.axes.Axes.plot`\n    or :meth:`bokeh:bokeh.plotting.Figure.line` for a description of accepted values.\nfill_kwargs : dict, optional\n    Keywords passed to the fill under the line (use ``fill_kwargs={'alpha': 0}``\n    to disable fill). Ignored for 2D KDE. Passed to\n    :meth:`bokeh.plotting.Figure.patch`.\nrug_kwargs : dict, optional\n    Keywords passed to the rug plot. Ignored if ``rug=False`` or for 2D KDE\n    Use ``space`` keyword (float) to control the position of the rugplot. The larger this number\n    the lower the rugplot. Passed to :class:`bokeh:bokeh.models.glyphs.Scatter`.\ncontour_kwargs : dict, optional\n    Keywords passed to :meth:`mpl:matplotlib.axes.Axes.contour`\n    to draw contour lines or :meth:`bokeh.plotting.Figure.patch`.\n    Ignored for 1D KDE.\ncontourf_kwargs : dict, optional\n    Keywords passed to :meth:`mpl:matplotlib.axes.Axes.contourf`\n    to draw filled contours. Ignored for 1D KDE.\npcolormesh_kwargs : dict, optional\n    Keywords passed to :meth:`mpl:matplotlib.axes.Axes.pcolormesh` or\n    :meth:`bokeh.plotting.Figure.image`.\n    Ignored for 1D KDE.\nis_circular : {False, True, \"radians\", \"degrees\"}. Default False\n    Select input type {\"radians\", \"degrees\"} for circular histogram or KDE plot. If True,\n    default input type is \"radians\". When this argument is present, it interprets ``values``\n    as a circular variable measured in radians and a circular KDE is used. Inputs in\n    \"degrees\" will undergo an internal conversion to radians.\nax : axes, optional\n    Matplotlib axes or bokeh figures.\nlegend : bool, default True\n    Add legend to the figure.\nbackend : {\"matplotlib\", \"bokeh\"}, default \"matplotlib\"\n    Select plotting backend.\nbackend_kwargs : dict, optional\n    These are kwargs specific to the backend being used, passed to\n    :func:`matplotlib.pyplot.subplots` or :class:`bokeh.plotting.figure`.\n    For additional documentation check the plotting method of the backend.\nshow : bool, optional\n    Call backend show function.\nreturn_glyph : bool, optional\n    Internal argument to return glyphs for bokeh.\n\nReturns\n-------\naxes : matplotlib.Axes or bokeh.plotting.Figure\n    Object containing the kde plot\nglyphs : list, optional\n    Bokeh glyphs present in plot.  Only provided if ``return_glyph`` is True.\n\nSee Also\n--------\nkde : One dimensional density estimation.\nplot_dist : Plot distribution as histogram or kernel density estimates.\n\nExamples\n--------\nPlot default KDE\n\n.. plot::\n    :context: close-figs\n\n    >>> import arviz as az\n    >>> non_centered = az.load_arviz_data('non_centered_eight')\n    >>> mu_posterior = np.concatenate(non_centered.posterior[\"mu\"].values)\n    >>> tau_posterior = np.concatenate(non_centered.posterior[\"tau\"].values)\n    >>> az.plot_kde(mu_posterior)\n\n\nPlot KDE with rugplot\n\n.. plot::\n    :context: close-figs\n\n    >>> az.plot_kde(mu_posterior, rug=True)\n\nPlot KDE with adaptive bandwidth\n\n.. plot::\n    :context: close-figs\n\n    >>> az.plot_kde(mu_posterior, adaptive=True)\n\nPlot KDE with a different bandwidth estimator\n\n.. plot::\n    :context: close-figs\n\n    >>> az.plot_kde(mu_posterior, bw=\"scott\")\n\nPlot KDE with a bandwidth specified manually\n\n.. plot::\n    :context: close-figs\n\n    >>> az.plot_kde(mu_posterior, bw=0.4)\n\nPlot KDE for a circular variable\n\n.. plot::\n    :context: close-figs\n\n    >>> rvs = np.random.vonmises(mu=np.pi, kappa=2, size=500)\n    >>> az.plot_kde(rvs, is_circular=True)\n\n\nPlot a cumulative distribution\n\n.. plot::\n    :context: close-figs\n\n    >>> az.plot_kde(mu_posterior, cumulative=True)\n\n\n\nRotate plot 90 degrees\n\n.. plot::\n    :context: close-figs\n\n    >>> az.plot_kde(mu_posterior, rotated=True)\n\n\nPlot 2d contour KDE\n\n.. plot::\n    :context: close-figs\n\n    >>> az.plot_kde(mu_posterior, values2=tau_posterior)\n\n\nPlot 2d contour KDE, without filling and contour lines using viridis cmap\n\n.. plot::\n    :context: close-figs\n\n    >>> az.plot_kde(mu_posterior, values2=tau_posterior,\n    ...             contour_kwargs={\"colors\":None, \"cmap\":plt.cm.viridis},\n    ...             contourf_kwargs={\"alpha\":0});\n\nPlot 2d contour KDE, set the number of levels to 3.\n\n.. plot::\n    :context: close-figs\n\n    >>> az.plot_kde(\n    ...     mu_posterior, values2=tau_posterior,\n    ...     contour_kwargs={\"levels\":3}, contourf_kwargs={\"levels\":3}\n    ... );\n\nPlot 2d contour KDE with 30%, 60% and 90% HDI contours.\n\n.. plot::\n    :context: close-figs\n\n    >>> az.plot_kde(mu_posterior, values2=tau_posterior, hdi_probs=[0.3, 0.6, 0.9])\n\nPlot 2d smooth KDE\n\n.. plot::\n    :context: close-figs\n\n    >>> az.plot_kde(mu_posterior, values2=tau_posterior, contour=False)\n\n\n\n\n\n\n\n\n","category":"method"},{"location":"api/plots/#ArviZPythonPlots.plot_khat-Tuple","page":"Plotting functions","title":"ArviZPythonPlots.plot_khat","text":"Plot Pareto tail indices :math:`\\hat{k}` for diagnosing convergence in PSIS-LOO.\n\nParameters\n----------\nkhats : ELPDData\n    The input Pareto tail indices to be plotted.\ncolor : str or array_like, default \"C0\"\n    Colors of the scatter plot, if color is a str all dots will have the same color,\n    if it is the size of the observations, each dot will have the specified color,\n    otherwise, it will be interpreted as a list of the dims to be used for the color\n    code. If Matplotlib c argument is passed, it will override the color argument.\nxlabels : bool, default False\n    Use coords as xticklabels.\nshow_hlines : bool, default False\n    Show the horizontal lines, by default at the values [0, 0.5, 0.7, 1].\nshow_bins : bool, default False\n    Show the percentage of khats falling in each bin, as delimited by hlines.\nbin_format : str, optional\n    The string is used as formatting guide calling ``bin_format.format(count, pct)``.\nthreshold : float, optional\n    Show the labels of k values larger than `threshold`. If ``None`` (default), no\n    observations will be highlighted.\nhover_label : bool, default False\n    Show the datapoint label when hovering over it with the mouse. Requires an interactive\n    backend.\nhover_format : str, default \"{1}\"\n    String used to format the hover label via ``hover_format.format(idx, coord_label)``\nfigsize : (float, float), optional\n    Figure size. If ``None`` it will be defined automatically.\ntextsize : float, optional\n    Text size scaling factor for labels, titles and lines. If ``None`` it will be autoscaled\n    based on `figsize`.\ncoords : mapping, optional\n    Coordinates of points to plot. **All** values are used for computation, but only a\n    a subset can be plotted for convenience. See :ref:`this section <common_coords>` for\n    usage examples.\nlegend : bool, default False\n    Include a legend to the plot. Only taken into account when color argument is a dim name.\nmarkersize : int, optional\n    markersize for scatter plot. Defaults to ``None`` in which case it will\n    be chosen based on autoscaling for figsize.\nax : axes, optional\n    Matplotlib axes or bokeh figures.\nhlines_kwargs : dict, optional\n    Additional keywords passed to\n    :meth:`matplotlib.axes.Axes.hlines`.\nbackend : {\"matplotlib\", \"bokeh\"}, default \"matplotlib\"\n    Select plotting backend.\nbackend_kwargs : dict, optional\n    These are kwargs specific to the backend being used, passed to\n    :func:`matplotlib.pyplot.subplots` or :class:`bokeh.plotting.figure`.\n    For additional documentation check the plotting method of the backend.\nshow : bool, optional\n    Call backend show function.\nkwargs :\n    Additional keywords passed to\n    :meth:`matplotlib.axes.Axes.scatter`.\n\nReturns\n-------\naxes : matplotlib_axes or bokeh_figures\n\nSee Also\n--------\npsislw : Pareto smoothed importance sampling (PSIS).\n\nExamples\n--------\nPlot estimated pareto shape parameters showing how many fall in each category.\n\n.. plot::\n    :context: close-figs\n\n    >>> import arviz as az\n    >>> radon = az.load_arviz_data(\"radon\")\n    >>> loo_radon = az.loo(radon, pointwise=True)\n    >>> az.plot_khat(loo_radon, show_bins=True)\n\nShow xlabels\n\n.. plot::\n    :context: close-figs\n\n    >>> centered_eight = az.load_arviz_data(\"centered_eight\")\n    >>> khats = az.loo(centered_eight, pointwise=True).pareto_k\n    >>> az.plot_khat(khats, xlabels=True, threshold=1)\n\nUse custom color scheme\n\n.. plot::\n    :context: close-figs\n\n    >>> counties = radon.posterior.County[radon.constant_data.county_idx].values\n    >>> colors = [\n    ...     \"blue\" if county[-1] in (\"A\", \"N\") else \"green\" for county in counties\n    ... ]\n    >>> az.plot_khat(loo_radon, color=colors)\n\nNotes\n-----\nThe Generalized Pareto distribution (GPD) diagnoses convergence rates for importance\nsampling. GPD has parameters offset, scale, and shape. The shape parameter (:math:`k`)\ntells the distribution's number of finite moments. The pre-asymptotic convergence rate\nof importance sampling can be estimated based on the fractional number of finite moments\nof the importance ratio distribution. GPD is fitted to the largest importance ratios and\ninterprets the estimated shape parameter :math:`k`, i.e., :math:`\\hat{k}` can then be\nused as a diagnostic (most importantly if :math:`\\hat{k} > 0.7`, then the convergence\nrate is impractically low). See [1]_.\n\nReferences\n----------\n.. [1] Vehtari, A., Simpson, D., Gelman, A., Yao, Y., Gabry, J. (2024).\n    Pareto Smoothed Importance Sampling. Journal of Machine Learning\n    Research, 25(72):1-58.\n\n\n\n\n\n\n\n\n","category":"method"},{"location":"api/plots/#ArviZPythonPlots.plot_lm-Tuple","page":"Plotting functions","title":"ArviZPythonPlots.plot_lm","text":"Posterior predictive and mean plots for regression-like data.\n\nParameters\n----------\ny : str or DataArray or ndarray\n    If str, variable name from ``observed_data``.\nidata : InferenceData, Optional\n    Optional only if ``y`` is not str.\nx : str, tuple of strings, DataArray or array-like, optional\n    If str or tuple, variable name from ``constant_data``.\n    If ndarray, could be 1D, or 2D for multiple plots.\n    If None, coords name of ``y`` (``y`` should be DataArray).\ny_model : str or Sequence, Optional\n    If str, variable name from ``posterior``.\n    Its dimensions should be same as ``y`` plus added chains and draws.\ny_hat : str, Optional\n    If str, variable name from ``posterior_predictive``.\n    Its dimensions should be same as ``y`` plus added chains and draws.\nnum_samples : int, Optional, Default 50\n    Significant if ``kind_pp`` is \"samples\" or ``kind_model`` is \"lines\".\n    Number of samples to be drawn from posterior predictive or\nkind_pp : {\"samples\", \"hdi\"}, Default \"samples\"\n    Options to visualize uncertainty in data.\nkind_model : {\"lines\", \"hdi\"}, Default \"lines\"\n    Options to visualize uncertainty in mean of the data.\nplot_dim : str, Optional\n    Necessary if ``y`` is multidimensional.\nbackend : str, Optional\n    Select plotting backend {\"matplotlib\",\"bokeh\"}. Default \"matplotlib\".\ny_kwargs : dict, optional\n    Passed to :meth:`mpl:matplotlib.axes.Axes.plot` in matplotlib\n    and :meth:`bokeh:bokeh.plotting.Figure.circle` in bokeh\ny_hat_plot_kwargs : dict, optional\n    Passed to :meth:`mpl:matplotlib.axes.Axes.plot` in matplotlib\n    and :meth:`bokeh:bokeh.plotting.Figure.circle` in bokeh\ny_hat_fill_kwargs : dict, optional\n    Passed to :func:`arviz.plot_hdi`\ny_model_plot_kwargs : dict, optional\n    Passed to :meth:`mpl:matplotlib.axes.Axes.plot` in matplotlib\n    and :meth:`bokeh:bokeh.plotting.Figure.line` in bokeh\ny_model_fill_kwargs : dict, optional\n    Significant if ``kind_model`` is \"hdi\". Passed to :func:`arviz.plot_hdi`\ny_model_mean_kwargs : dict, optional\n    Passed to :meth:`mpl:matplotlib.axes.Axes.plot` in matplotlib\n    and :meth:`bokeh:bokeh.plotting.Figure.line` in bokeh\nbackend_kwargs : dict, optional\n    These are kwargs specific to the backend being used. Passed to\n    :func:`matplotlib.pyplot.subplots` or\n    :func:`bokeh.plotting.figure`.\nfigsize : (float, float), optional\n    Figure size. If None it will be defined automatically.\ntextsize : float, optional\n    Text size scaling factor for labels, titles and lines. If None it will be\n    autoscaled based on ``figsize``.\naxes : 2D numpy array-like of matplotlib_axes or bokeh_figures, optional\n    A 2D array of locations into which to plot the densities. If not supplied, Arviz will create\n    its own array of plot areas (and return it).\nshow : bool, optional\n    Call backend show function.\nlegend : bool, optional\n    Add legend to figure. By default True.\ngrid : bool, optional\n    Add grid to figure. By default True.\n\n\nReturns\n-------\naxes: matplotlib axes or bokeh figures\n\nSee Also\n--------\nplot_ts : Plot timeseries data\nplot_ppc : Plot for posterior/prior predictive checks\n\nExamples\n--------\nPlot regression default plot\n\n.. plot::\n    :context: close-figs\n\n    >>> import arviz as az\n    >>> import numpy as np\n    >>> import xarray as xr\n    >>> idata = az.load_arviz_data('regression1d')\n    >>> x = xr.DataArray(np.linspace(0, 1, 100))\n    >>> idata.posterior[\"y_model\"] = idata.posterior[\"intercept\"] + idata.posterior[\"slope\"]*x\n    >>> az.plot_lm(idata=idata, y=\"y\", x=x)\n\nPlot regression data and mean uncertainty\n\n.. plot::\n    :context: close-figs\n\n    >>> az.plot_lm(idata=idata, y=\"y\", x=x, y_model=\"y_model\")\n\nPlot regression data and mean uncertainty in hdi form\n\n.. plot::\n    :context: close-figs\n\n    >>> az.plot_lm(\n    ...     idata=idata, y=\"y\", x=x, y_model=\"y_model\", kind_pp=\"hdi\", kind_model=\"hdi\"\n    ... )\n\nPlot regression data for multi-dimensional y using plot_dim\n\n.. plot::\n    :context: close-figs\n\n    >>> data = az.from_dict(\n    ...     observed_data = { \"y\": np.random.normal(size=(5, 7)) },\n    ...     posterior_predictive = {\"y\": np.random.randn(4, 1000, 5, 7) / 2},\n    ...     dims={\"y\": [\"dim1\", \"dim2\"]},\n    ...     coords={\"dim1\": range(5), \"dim2\": range(7)}\n    ... )\n    >>> az.plot_lm(idata=data, y=\"y\", plot_dim=\"dim1\")\n\n\n\n\n\n\n\n","category":"method"},{"location":"api/plots/#ArviZPythonPlots.plot_loo_pit-Tuple","page":"Plotting functions","title":"ArviZPythonPlots.plot_loo_pit","text":"Plot Leave-One-Out (LOO) probability integral transformation (PIT) predictive checks.\n\nParameters\n----------\nidata : InferenceData\n    :class:`arviz.InferenceData` object.\ny : array, DataArray or str\n    Observed data. If str, ``idata`` must be present and contain the observed data group\ny_hat : array, DataArray or str\n    Posterior predictive samples for ``y``. It must have the same shape as y plus an\n    extra dimension at the end of size n_samples (chains and draws stacked). If str or\n    None, ``idata`` must contain the posterior predictive group. If None, ``y_hat`` is taken\n    equal to y, thus, y must be str too.\nlog_weights : array or DataArray\n    Smoothed log_weights. It must have the same shape as ``y_hat``\necdf : bool, optional\n    Plot the difference between the LOO-PIT Empirical Cumulative Distribution Function\n    (ECDF) and the uniform CDF instead of LOO-PIT kde.\n    In this case, instead of overlaying uniform distributions, the beta ``hdi_prob``\n    around the theoretical uniform CDF is shown. This approximation only holds\n    for large S and ECDF values not very close to 0 nor 1. For more information, see\n    `Vehtari et al. (2021)`, `Appendix G <https://avehtari.github.io/rhat_ess/rhat_ess.html>`_.\necdf_fill : bool, optional\n    Use :meth:`matplotlib.axes.Axes.fill_between` to mark the area\n    inside the credible interval. Otherwise, plot the\n    border lines.\nn_unif : int, optional\n    Number of datasets to simulate and overlay from the uniform distribution.\nuse_hdi : bool, optional\n    Compute expected hdi values instead of overlaying the sampled uniform distributions.\nhdi_prob : float, optional\n    Probability for the highest density interval. Works with ``use_hdi=True`` or ``ecdf=True``.\nfigsize : (float, float), optional\n    If None, size is (8 + numvars, 8 + numvars)\ntextsize : int, optional\n    Text size for labels. If None it will be autoscaled based on ``figsize``.\nlabeller : Labeller, optional\n    Class providing the method ``make_pp_label`` to generate the labels in the plot titles.\n    Read the :ref:`label_guide` for more details and usage examples.\ncolor : str or array_like, optional\n    Color of the LOO-PIT estimated pdf plot. If ``plot_unif_kwargs`` has no \"color\" key,\n    a slightly lighter color than this argument will be used for the uniform kde lines.\n    This will ensure that LOO-PIT kde and uniform kde have different default colors.\nlegend : bool, optional\n    Show the legend of the figure.\nax : axes, optional\n    Matplotlib axes or bokeh figures.\nplot_kwargs : dict, optional\n    Additional keywords passed to :meth:`matplotlib.axes.Axes.plot`\n    for LOO-PIT line (kde or ECDF)\nplot_unif_kwargs : dict, optional\n    Additional keywords passed to :meth:`matplotlib.axes.Axes.plot` for\n    overlaid uniform distributions or for beta credible interval\n    lines if ``ecdf=True``\nhdi_kwargs : dict, optional\n    Additional keywords passed to :meth:`matplotlib.axes.Axes.axhspan`\nfill_kwargs : dict, optional\n    Additional kwargs passed to :meth:`matplotlib.axes.Axes.fill_between`\nbackend : str, optional\n    Select plotting backend {\"matplotlib\",\"bokeh\"}. Default \"matplotlib\".\nbackend_kwargs : bool, optional\n    These are kwargs specific to the backend being used, passed to\n    :func:`matplotlib.pyplot.subplots` or\n    :func:`bokeh.plotting.figure`. For additional documentation\n    check the plotting method of the backend.\nshow : bool, optional\n    Call backend show function.\n\nReturns\n-------\naxes : matplotlib_axes or bokeh_figures\n\nSee Also\n--------\nplot_bpv : Plot Bayesian p-value for observed data and Posterior/Prior predictive.\nloo_pit : Compute leave one out (PSIS-LOO) probability integral transform (PIT) values.\n\nReferences\n----------\n* Gabry et al. (2017) see https://arxiv.org/abs/1709.01449\n* https://mc-stan.org/bayesplot/reference/PPC-loo.html\n* Gelman et al. BDA (2014) Section 6.3\n\nExamples\n--------\nPlot LOO-PIT predictive checks overlaying the KDE of the LOO-PIT values to several\nrealizations of uniform variable sampling with the same number of observations.\n\n.. plot::\n    :context: close-figs\n\n    >>> import arviz as az\n    >>> idata = az.load_arviz_data(\"radon\")\n    >>> az.plot_loo_pit(idata=idata, y=\"y\")\n\nFill the area containing the 94% highest density interval of the difference between uniform\nvariables empirical CDF and the real uniform CDF. A LOO-PIT ECDF clearly outside of these\ntheoretical boundaries indicates that the observations and the posterior predictive\nsamples do not follow the same distribution.\n\n.. plot::\n    :context: close-figs\n\n    >>> az.plot_loo_pit(idata=idata, y=\"y\", ecdf=True)\n\n\n\n\n\n\n\n\n","category":"method"},{"location":"api/plots/#ArviZPythonPlots.plot_mcse-Tuple","page":"Plotting functions","title":"ArviZPythonPlots.plot_mcse","text":"Plot quantile or local Monte Carlo Standard Error.\n\nParameters\n----------\nidata : obj\n    Any object that can be converted to an :class:`arviz.InferenceData` object\n    Refer to documentation of :func:`arviz.convert_to_dataset` for details\nvar_names : list of variable names, optional\n    Variables to be plotted. Prefix the variables by ``~`` when you want to exclude\n    them from the plot.\nfilter_vars : {None, \"like\", \"regex\"}, optional, default=None\n    If `None` (default), interpret var_names as the real variables names. If \"like\",\n    interpret var_names as substrings of the real variables names. If \"regex\",\n    interpret var_names as regular expressions on the real variables names. A la\n    `pandas.filter`.\ncoords : dict, optional\n    Coordinates of var_names to be plotted. Passed to :meth:`xarray.Dataset.sel`\nerrorbar : bool, optional\n    Plot quantile value +/- mcse instead of plotting mcse.\ngrid : tuple\n    Number of rows and columns. Defaults to None, the rows and columns are\n    automatically inferred.\nfigsize : (float, float), optional\n    Figure size. If None it will be defined automatically.\ntextsize : float, optional\n    Text size scaling factor for labels, titles and lines. If None it will be autoscaled based\n    on figsize.\nextra_methods : bool, optional\n    Plot mean and sd MCSE as horizontal lines. Only taken into account when\n    ``errorbar=False``.\nrug : bool\n    Plot rug plot of values diverging or that reached the max tree depth.\nrug_kind : bool\n    Variable in sample stats to use as rug mask. Must be a boolean variable.\nn_points : int\n    Number of points for which to plot their quantile/local ess or number of subsets\n    in the evolution plot.\nlabeller : Labeller, optional\n    Class providing the method `make_label_vert` to generate the labels in the plot titles.\n    Read the :ref:`label_guide` for more details and usage examples.\nax : 2D array-like of matplotlib_axes or bokeh_figures, optional\n    A 2D array of locations into which to plot the densities. If not supplied, Arviz will create\n    its own array of plot areas (and return it).\nrug_kwargs : dict\n    kwargs passed to rug plot in\n    :meth:`mpl:matplotlib.axes.Axes.plot` or :class:`bokeh:bokeh.models.glyphs.Scatter`.\nextra_kwargs : dict, optional\n    kwargs passed as extra method lines in\n    :meth:`mpl:matplotlib.axes.Axes.axhline` or :class:`bokeh:bokeh.models.Span`\ntext_kwargs : dict, optional\n    kwargs passed to :meth:`mpl:matplotlib.axes.Axes.annotate` for extra methods lines labels.\n    It accepts the additional key ``x`` to set ``xy=(text_kwargs[\"x\"], mcse)``.\n    text_kwargs are ignored for the bokeh plotting backend.\nbackend : str, optional\n    Select plotting backend {\"matplotlib\",\"bokeh\"}. Default \"matplotlib\".\nbackend_kwargs : bool, optional\n    These are kwargs specific to the backend being passed to\n    :func:`matplotlib.pyplot.subplots` or :func:`bokeh.plotting.figure`.\nshow: bool, optional\n    Call backend show function.\n**kwargs\n    Passed as-is to :meth:`mpl:matplotlib.axes.Axes.hist` or\n    :meth:`mpl:matplotlib.axes.Axes.plot` in matplotlib depending on the value of `kind`.\n\nReturns\n-------\naxes : matplotlib axes or bokeh figures\n\nSee Also\n--------\n:func:`arviz.mcse`: Calculate Markov Chain Standard Error statistic.\n\nReferences\n----------\n.. [1] Vehtari et al. (2021). Rank-normalization, folding, and\n    localization: An improved Rhat for assessing convergence of\n    MCMC. Bayesian analysis, 16(2):667-718.\n\nExamples\n--------\nPlot quantile Monte Carlo Standard Error.\n\n.. plot::\n    :context: close-figs\n\n    >>> import arviz as az\n    >>> idata = az.load_arviz_data(\"centered_eight\")\n    >>> coords = {\"school\": [\"Deerfield\", \"Lawrenceville\"]}\n    >>> az.plot_mcse(\n    ...     idata, var_names=[\"mu\", \"theta\"], coords=coords\n    ... )\n\n\n\n\n\n\n\n\n","category":"method"},{"location":"api/plots/#ArviZPythonPlots.plot_pair-Tuple","page":"Plotting functions","title":"ArviZPythonPlots.plot_pair","text":"\nPlot a scatter, kde and/or hexbin matrix with (optional) marginals on the diagonal.\n\nParameters\n----------\ndata: obj\n    Any object that can be converted to an :class:`arviz.InferenceData` object.\n    Refer to documentation of :func:`arviz.convert_to_dataset` for details\ngroup: str, optional\n    Specifies which InferenceData group should be plotted.  Defaults to 'posterior'.\nvar_names: list of variable names, optional\n    Variables to be plotted, if None all variable are plotted. Prefix the\n    variables by ``~`` when you want to exclude them from the plot.\nfilter_vars: {None, \"like\", \"regex\"}, optional, default=None\n    If `None` (default), interpret var_names as the real variables names. If \"like\",\n    interpret var_names as substrings of the real variables names. If \"regex\",\n    interpret var_names as regular expressions on the real variables names. A la\n    ``pandas.filter``.\ncombine_dims : set_like of str, optional\n    List of dimensions to reduce. Defaults to reducing only the \"chain\" and \"draw\" dimensions.\n    See the :ref:`this section <common_combine_dims>` for usage examples.\ncoords: mapping, optional\n    Coordinates of var_names to be plotted. Passed to :meth:`xarray.Dataset.sel`.\nmarginals: bool, optional\n    If True pairplot will include marginal distributions for every variable\nfigsize: figure size tuple\n    If None, size is (8 + numvars, 8 + numvars)\ntextsize: int\n    Text size for labels. If None it will be autoscaled based on ``figsize``.\nkind : str or List[str]\n    Type of plot to display (scatter, kde and/or hexbin)\ngridsize: int or (int, int), optional\n    Only works for ``kind=hexbin``. The number of hexagons in the x-direction.\n    The corresponding number of hexagons in the y-direction is chosen\n    such that the hexagons are approximately regular. Alternatively, gridsize\n    can be a tuple with two elements specifying the number of hexagons\n    in the x-direction and the y-direction.\ndivergences: Boolean\n    If True divergences will be plotted in a different color, only if group is either 'prior'\n    or 'posterior'.\ncolorbar: bool\n    If True a colorbar will be included as part of the plot (Defaults to False).\n    Only works when ``kind=hexbin``\nlabeller : labeller instance, optional\n    Class providing the method ``make_label_vert`` to generate the labels in the plot.\n    Read the :ref:`label_guide` for more details and usage examples.\nax: axes, optional\n    Matplotlib axes or bokeh figures.\ndivergences_kwargs: dicts, optional\n    Additional keywords passed to :meth:`matplotlib.axes.Axes.scatter` for divergences\nscatter_kwargs:\n    Additional keywords passed to :meth:`matplotlib.axes.Axes.scatter` when using scatter kind\nkde_kwargs: dict, optional\n    Additional keywords passed to :func:`arviz.plot_kde` when using kde kind\nhexbin_kwargs: dict, optional\n    Additional keywords passed to :meth:`matplotlib.axes.Axes.hexbin` when\n    using hexbin kind\nbackend: str, optional\n    Select plotting backend {\"matplotlib\",\"bokeh\"}. Default \"matplotlib\".\nbackend_kwargs: bool, optional\n    These are kwargs specific to the backend being used, passed to\n    :func:`matplotlib.pyplot.subplots` or\n    :func:`bokeh.plotting.figure`.\nmarginal_kwargs: dict, optional\n    Additional keywords passed to :func:`arviz.plot_dist`, modifying the\n    marginal distributions plotted in the diagonal.\npoint_estimate: str, optional\n    Select point estimate from 'mean', 'mode' or 'median'. The point estimate will be\n    plotted using a scatter marker and vertical/horizontal lines.\npoint_estimate_kwargs: dict, optional\n    Additional keywords passed to :meth:`matplotlib.axes.Axes.axvline`,\n    :meth:`matplotlib.axes.Axes.axhline` (matplotlib) or\n    :class:`bokeh:bokeh.models.Span` (bokeh)\npoint_estimate_marker_kwargs: dict, optional\n    Additional keywords passed to :meth:`matplotlib.axes.Axes.scatter`\n    or :meth:`bokeh:bokeh.plotting.Figure.square` in point\n    estimate plot. Not available in bokeh\nreference_values: dict, optional\n    Reference values for the plotted variables. The Reference values will be plotted\n    using a scatter marker\nreference_values_kwargs: dict, optional\n    Additional keywords passed to :meth:`matplotlib.axes.Axes.plot` or\n    :meth:`bokeh:bokeh.plotting.Figure.circle` in reference values plot\nshow: bool, optional\n    Call backend show function.\n\nReturns\n-------\naxes: matplotlib axes or bokeh figures\n\nExamples\n--------\nKDE Pair Plot\n\n.. plot::\n    :context: close-figs\n\n    >>> import arviz as az\n    >>> centered = az.load_arviz_data('centered_eight')\n    >>> coords = {'school': ['Choate', 'Deerfield']}\n    >>> az.plot_pair(centered,\n    >>>             var_names=['theta', 'mu', 'tau'],\n    >>>             kind='kde',\n    >>>             coords=coords,\n    >>>             divergences=True,\n    >>>             textsize=18)\n\nHexbin pair plot\n\n.. plot::\n    :context: close-figs\n\n    >>> az.plot_pair(centered,\n    >>>             var_names=['theta', 'mu'],\n    >>>             coords=coords,\n    >>>             textsize=18,\n    >>>             kind='hexbin')\n\nPair plot showing divergences and select variables with regular expressions\n\n.. plot::\n    :context: close-figs\n\n    >>> az.plot_pair(centered,\n    ...             var_names=['^t', 'mu'],\n    ...             filter_vars=\"regex\",\n    ...             coords=coords,\n    ...             divergences=True,\n    ...             textsize=18)\n\n\n\n\n\n\n\n","category":"method"},{"location":"api/plots/#ArviZPythonPlots.plot_parallel-Tuple","page":"Plotting functions","title":"ArviZPythonPlots.plot_parallel","text":"\nPlot parallel coordinates plot showing posterior points with and without divergences.\n\nDescribed by https://arxiv.org/abs/1709.01449\n\nParameters\n----------\ndata: obj\n    Any object that can be converted to an :class:`arviz.InferenceData` object\n    refer to documentation of :func:`arviz.convert_to_dataset` for details\nvar_names: list of variable names\n    Variables to be plotted, if `None` all variables are plotted. Can be used to change the\n    order of the plotted variables. Prefix the variables by ``~`` when you want to exclude\n    them from the plot.\nfilter_vars: {None, \"like\", \"regex\"}, optional, default=None\n    If `None` (default), interpret var_names as the real variables names. If \"like\",\n    interpret var_names as substrings of the real variables names. If \"regex\",\n    interpret var_names as regular expressions on the real variables names. A la\n    ``pandas.filter``.\ncoords: mapping, optional\n    Coordinates of ``var_names`` to be plotted.\n    Passed to :meth:`xarray.Dataset.sel`.\nfigsize: tuple\n    Figure size. If None it will be defined automatically.\ntextsize: float\n    Text size scaling factor for labels, titles and lines. If None it will be autoscaled based\n    on ``figsize``.\nlegend: bool\n    Flag for plotting legend (defaults to True)\ncolornd: valid matplotlib color\n    color for non-divergent points. Defaults to 'k'\ncolord: valid matplotlib color\n    color for divergent points. Defaults to 'C1'\nshadend: float\n    Alpha blending value for non-divergent points, between 0 (invisible) and 1 (opaque).\n    Defaults to .025\nlabeller : labeller instance, optional\n    Class providing the method ``make_label_vert`` to generate the labels in the plot.\n    Read the :ref:`label_guide` for more details and usage examples.\nax: axes, optional\n    Matplotlib axes or bokeh figures.\nnorm_method: str\n    Method for normalizing the data. Methods include normal, minmax and rank.\n    Defaults to none.\nbackend: str, optional\n    Select plotting backend {\"matplotlib\",\"bokeh\"}. Default \"matplotlib\".\nbackend_config: dict, optional\n    Currently specifies the bounds to use for bokeh axes.\n    Defaults to value set in ``rcParams``.\nbackend_kwargs: bool, optional\n    These are kwargs specific to the backend being used, passed to\n    :func:`matplotlib.pyplot.subplots` or\n    :func:`bokeh.plotting.figure`.\nshow: bool, optional\n    Call backend show function.\n\nReturns\n-------\naxes: matplotlib axes or bokeh figures\n\nSee Also\n--------\nplot_pair : Plot a scatter, kde and/or hexbin matrix with (optional) marginals on the diagonal.\nplot_trace : Plot distribution (histogram or kernel density estimates) and sampled values\n             or rank plot\n\nExamples\n--------\nPlot default parallel plot\n\n.. plot::\n    :context: close-figs\n\n    >>> import arviz as az\n    >>> data = az.load_arviz_data('centered_eight')\n    >>> az.plot_parallel(data, var_names=[\"mu\", \"tau\"])\n\n\nPlot parallel plot with normalization\n\n.. plot::\n    :context: close-figs\n\n    >>> az.plot_parallel(data, var_names=[\"theta\", \"tau\", \"mu\"], norm_method=\"normal\")\n\nPlot parallel plot with minmax\n\n.. plot::\n    :context: close-figs\n\n    >>> ax = az.plot_parallel(data, var_names=[\"theta\", \"tau\", \"mu\"], norm_method=\"minmax\")\n    >>> ax.set_xticklabels(ax.get_xticklabels(), rotation=45)\n\nPlot parallel plot with rank\n\n.. plot::\n    :context: close-figs\n\n    >>> ax = az.plot_parallel(data, var_names=[\"theta\", \"tau\", \"mu\"], norm_method=\"rank\")\n    >>> ax.set_xticklabels(ax.get_xticklabels(), rotation=45)\n\n\n\n\n\n\n\n","category":"method"},{"location":"api/plots/#ArviZPythonPlots.plot_posterior-Tuple","page":"Plotting functions","title":"ArviZPythonPlots.plot_posterior","text":"Plot Posterior densities in the style of John K. Kruschke's book.\n\nParameters\n----------\ndata: obj\n    Any object that can be converted to an :class:`arviz.InferenceData` object.\n    Refer to the documentation of :func:`arviz.convert_to_dataset` for details\nvar_names: list of variable names\n    Variables to be plotted, two variables are required. Prefix the variables with ``~``\n    when you want to exclude them from the plot.\nfilter_vars: {None, \"like\", \"regex\"}, optional, default=None\n    If `None` (default), interpret var_names as the real variables names. If \"like\",\n    interpret var_names as substrings of the real variables names. If \"regex\",\n    interpret var_names as regular expressions on the real variables names. A la\n    ``pandas.filter``.\ncombine_dims : set_like of str, optional\n    List of dimensions to reduce. Defaults to reducing only the \"chain\" and \"draw\" dimensions.\n    See the :ref:`this section <common_combine_dims>` for usage examples.\ntransform: callable\n    Function to transform data (defaults to None i.e.the identity function)\ncoords: mapping, optional\n    Coordinates of var_names to be plotted. Passed to :meth:`xarray.Dataset.sel`\ngrid : tuple\n    Number of rows and columns. Defaults to None, the rows and columns are\n    automatically inferred.\nfigsize: tuple\n    Figure size. If None it will be defined automatically.\ntextsize: float\n    Text size scaling factor for labels, titles and lines. If None it will be autoscaled based\n    on ``figsize``.\nhdi_prob: float, optional\n    Plots highest density interval for chosen percentage of density.\n    Use 'hide' to hide the highest density interval. Defaults to 0.94.\nmultimodal: bool\n    If true (default) it may compute more than one credible interval if the distribution is\n    multimodal and the modes are well separated.\nskipna : bool\n    If true ignores nan values when computing the hdi and point estimates. Defaults to false.\nround_to: int, optional\n    Controls formatting of floats. Defaults to 2 or the integer part, whichever is bigger.\npoint_estimate: Optional[str]\n    Plot point estimate per variable. Values should be 'mean', 'median', 'mode' or None.\n    Defaults to 'auto' i.e. it falls back to default set in rcParams.\ngroup: str, optional\n    Specifies which InferenceData group should be plotted. Defaults to 'posterior'.\nrope : list, tuple or dictionary of {str: tuples or lists}, optional\n    A dictionary of tuples with the lower and upper values of the Region Of Practical\n    Equivalence. See :ref:`this section <common_rope>` for usage examples.\nref_val: float or dictionary of floats\n    display the percentage below and above the values in ref_val. Must be None (default),\n    a constant, a list or a dictionary like see an example below. If a list is provided, its\n    length should match the number of variables.\nrope_color: str, optional\n    Specifies the color of ROPE and displayed percentage within ROPE\nref_val_color: str, optional\n    Specifies the color of the displayed percentage\nkind: str\n    Type of plot to display (kde or hist) For discrete variables this argument is ignored and\n    a histogram is always used. Defaults to rcParam ``plot.density_kind``\nbw: float or str, optional\n    If numeric, indicates the bandwidth and must be positive.\n    If str, indicates the method to estimate the bandwidth and must be\n    one of \"scott\", \"silverman\", \"isj\" or \"experimental\" when `circular` is False\n    and \"taylor\" (for now) when `circular` is True.\n    Defaults to \"default\" which means \"experimental\" when variable is not circular\n    and \"taylor\" when it is. Only works if `kind == kde`.\ncircular: bool, optional\n    If True, it interprets the values passed are from a circular variable measured in radians\n    and a circular KDE is used. Only valid for 1D KDE. Defaults to False.\n    Only works if `kind == kde`.\nbins: integer or sequence or 'auto', optional\n    Controls the number of bins,accepts the same keywords :func:`matplotlib.pyplot.hist` does.\n    Only works if `kind == hist`. If None (default) it will use `auto` for continuous variables\n    and `range(xmin, xmax + 1)` for discrete variables.\nlabeller : labeller instance, optional\n    Class providing the method ``make_label_vert`` to generate the labels in the plot titles.\n    Read the :ref:`label_guide` for more details and usage examples.\nax: numpy array-like of matplotlib axes or bokeh figures, optional\n    A 2D array of locations into which to plot the densities. If not supplied, Arviz will create\n    its own array of plot areas (and return it).\nbackend: str, optional\n    Select plotting backend {\"matplotlib\",\"bokeh\"}. Default \"matplotlib\".\nbackend_kwargs: bool, optional\n    These are kwargs specific to the backend being used, passed to\n    :func:`matplotlib.pyplot.subplots` or :func:`bokeh.plotting.figure`\nshow: bool, optional\n    Call backend show function.\n**kwargs\n    Passed as-is to :func:`matplotlib.pyplot.hist` or :func:`matplotlib.pyplot.plot` function\n    depending on the value of `kind`.\n\nReturns\n-------\naxes: matplotlib axes or bokeh figures\n\nSee Also\n--------\nplot_dist : Plot distribution as histogram or kernel density estimates.\nplot_density : Generate KDE plots for continuous variables and histograms for discrete ones.\nplot_forest : Forest plot to compare HDI intervals from a number of distributions.\n\nExamples\n--------\nShow a default kernel density plot following style of John Kruschke\n\n.. plot::\n    :context: close-figs\n\n    >>> import arviz as az\n    >>> data = az.load_arviz_data('centered_eight')\n    >>> az.plot_posterior(data)\n\nPlot subset variables by specifying variable name exactly\n\n.. plot::\n    :context: close-figs\n\n    >>> az.plot_posterior(data, var_names=['mu'])\n\nPlot Region of Practical Equivalence (rope) and select variables with regular expressions\n\n.. plot::\n    :context: close-figs\n\n    >>> az.plot_posterior(data, var_names=['mu', '^the'], filter_vars=\"regex\", rope=(-1, 1))\n\nPlot Region of Practical Equivalence for selected distributions\n\n.. plot::\n    :context: close-figs\n\n    >>> rope = {'mu': [{'rope': (-2, 2)}], 'theta': [{'school': 'Choate', 'rope': (2, 4)}]}\n    >>> az.plot_posterior(data, var_names=['mu', 'theta'], rope=rope)\n\nUsing `coords` argument to plot only a subset of data\n\n.. plot::\n    :context: close-figs\n\n    >>> coords = {\"school\": [\"Choate\",\"Phillips Exeter\"]}\n    >>> az.plot_posterior(data, var_names=[\"mu\", \"theta\"], coords=coords)\n\nAdd reference lines\n\n.. plot::\n    :context: close-figs\n\n    >>> az.plot_posterior(data, var_names=['mu', 'theta'], ref_val=0)\n\nShow point estimate of distribution\n\n.. plot::\n    :context: close-figs\n\n    >>> az.plot_posterior(data, var_names=['mu', 'theta'], point_estimate='mode')\n\nShow reference values using variable names and coordinates\n\n.. plot::\n    :context: close-figs\n\n    >>> az.plot_posterior(data, ref_val= {\"theta\": [{\"school\": \"Deerfield\", \"ref_val\": 4},\n    ...                                             {\"school\": \"Choate\", \"ref_val\": 3}]})\n\nShow reference values using a list\n\n.. plot::\n    :context: close-figs\n\n    >>> az.plot_posterior(data, ref_val=[1] + [5] * 8 + [1])\n\n\nPlot posterior as a histogram\n\n.. plot::\n    :context: close-figs\n\n    >>> az.plot_posterior(data, var_names=['mu'], kind='hist')\n\nChange size of highest density interval\n\n.. plot::\n    :context: close-figs\n\n    >>> az.plot_posterior(data, var_names=['mu'], hdi_prob=.75)\n\n\n\n\n\n\n\n","category":"method"},{"location":"api/plots/#ArviZPythonPlots.plot_ppc-Tuple","page":"Plotting functions","title":"ArviZPythonPlots.plot_ppc","text":"\nPlot for posterior/prior predictive checks.\n\nParameters\n----------\ndata : InferenceData\n    :class:`arviz.InferenceData` object containing the observed and posterior/prior\n    predictive data.\nkind : str, default \"kde\"\n    Type of plot to display (\"kde\", \"cumulative\", or \"scatter\").\nalpha : float, optional\n    Opacity of posterior/prior predictive density curves.\n    Defaults to 0.2 for ``kind = kde`` and cumulative, for scatter defaults to 0.7.\nmean : bool, default True\n    Whether or not to plot the mean posterior/prior predictive distribution.\nobserved : bool, optional\n    Whether or not to plot the observed data. Defaults to True for ``group = posterior``\n    and False for ``group = prior``.\nobserved_rug : bool, default False\n    Whether or not to plot a rug plot for the observed data. Only valid if `observed` is\n    `True` and for kind `kde` or `cumulative`.\ncolor : list, optional\n    List with valid matplotlib colors corresponding to the posterior/prior predictive\n    distribution, observed data and mean of the posterior/prior predictive distribution.\n    Defaults to [\"C0\", \"k\", \"C1\"].\ngrid : tuple, optional\n    Number of rows and columns. Defaults to None, the rows and columns are\n    automatically inferred.\nfigsize : tuple, optional\n    Figure size. If None, it will be defined automatically.\ntextsize : float, optional\n    Text size scaling factor for labels, titles and lines. If None, it will be\n    autoscaled based on ``figsize``.\ndata_pairs : dict, optional\n    Dictionary containing relations between observed data and posterior/prior predictive data.\n    Dictionary structure:\n\n    - key = data var_name\n    - value = posterior/prior predictive var_name\n\n    For example, ``data_pairs = {'y' : 'y_hat'}``\n    If None, it will assume that the observed data and the posterior/prior\n    predictive data have the same variable name.\nvar_names : list of str, optional\n    Variables to be plotted, if `None` all variable are plotted. Prefix the\n    variables by ``~`` when you want to exclude them from the plot.\nfilter_vars : {None, \"like\", \"regex\"}, default None\n    If `None` (default), interpret var_names as the real variables names. If \"like\",\n    interpret var_names as substrings of the real variables names. If \"regex\",\n    interpret var_names as regular expressions on the real variables names. A la\n    ``pandas.filter``.\ncoords : dict, optional\n    Dictionary mapping dimensions to selected coordinates to be plotted.\n    Dimensions without a mapping specified will include all coordinates for\n    that dimension. Defaults to including all coordinates for all\n    dimensions if None.\nflatten : list\n    List of dimensions to flatten in ``observed_data``. Only flattens across the coordinates\n    specified in the ``coords`` argument. Defaults to flattening all of the dimensions.\nflatten_pp : list\n    List of dimensions to flatten in posterior_predictive/prior_predictive. Only flattens\n    across the coordinates specified in the ``coords`` argument. Defaults to flattening all\n    of the dimensions. Dimensions should match flatten excluding dimensions for ``data_pairs``\n    parameters. If ``flatten`` is defined and ``flatten_pp`` is None, then\n    ``flatten_pp = flatten``.\nnum_pp_samples : int\n    The number of posterior/prior predictive samples to plot. For ``kind`` = 'scatter' and\n    ``animation = False`` if defaults to a maximum of 5 samples and will set jitter to 0.7.\n    unless defined. Otherwise it defaults to all provided samples.\nrandom_seed : int\n    Random number generator seed passed to ``numpy.random.seed`` to allow\n    reproducibility of the plot. By default, no seed will be provided\n    and the plot will change each call if a random sample is specified\n    by ``num_pp_samples``.\njitter : float, default 0\n    If ``kind`` is \"scatter\", jitter will add random uniform noise to the height\n    of the ppc samples and observed data.\nanimated : bool, default False\n    Create an animation of one posterior/prior predictive sample per frame.\n    Only works with matploblib backend.\n    To run animations inside a notebook you have to use the `nbAgg` matplotlib's backend.\n    Try with `%matplotlib notebook` or  `%matplotlib  nbAgg`. You can switch back to the\n    default matplotlib's backend with `%matplotlib  inline` or `%matplotlib  auto`.\n    If switching back and forth between matplotlib's backend, you may need to run twice the cell\n    with the animation.\n    If you experience problems rendering the animation try setting\n    ``animation_kwargs({'blit':False})`` or changing the matplotlib's backend (e.g. to TkAgg)\n    If you run the animation from a script write ``ax, ani = az.plot_ppc(.)``\nanimation_kwargs : dict\n    Keywords passed to  :class:`matplotlib.animation.FuncAnimation`. Ignored with\n    matplotlib backend.\nlegend : bool, default True\n    Add legend to figure.\nlabeller : labeller, optional\n    Class providing the method ``make_pp_label`` to generate the labels in the plot titles.\n    Read the :ref:`label_guide` for more details and usage examples.\nax : numpy array-like of matplotlib_axes or bokeh figures, optional\n    A 2D array of locations into which to plot the densities. If not supplied, Arviz will create\n    its own array of plot areas (and return it).\nbackend : str, optional\n    Select plotting backend {\"matplotlib\",\"bokeh\"}. Default to \"matplotlib\".\nbackend_kwargs : dict, optional\n    These are kwargs specific to the backend being used, passed to\n    :func:`matplotlib.pyplot.subplots` or :func:`bokeh.plotting.figure`.\n    For additional documentation check the plotting method of the backend.\ngroup : {\"prior\", \"posterior\"}, optional\n    Specifies which InferenceData group should be plotted. Defaults to 'posterior'.\n    Other value can be 'prior'.\nshow : bool, optional\n    Call backend show function.\n\nReturns\n-------\naxes : matplotlib_axes or bokeh_figures\nani : matplotlib.animation.FuncAnimation, optional\n    Only provided if `animated` is ``True``.\n\nSee Also\n--------\nplot_bpv : Plot Bayesian p-value for observed data and Posterior/Prior predictive.\nplot_loo_pit : Plot for posterior predictive checks using cross validation.\nplot_lm : Posterior predictive and mean plots for regression-like data.\nplot_ts : Plot timeseries data.\n\nExamples\n--------\nPlot the observed data KDE overlaid on posterior predictive KDEs.\n\n.. plot::\n    :context: close-figs\n\n    >>> import arviz as az\n    >>> data = az.load_arviz_data('radon')\n    >>> az.plot_ppc(data, data_pairs={\"y\":\"y\"})\n\nPlot the overlay with empirical CDFs.\n\n.. plot::\n    :context: close-figs\n\n    >>> az.plot_ppc(data, kind='cumulative')\n\nUse the ``coords`` and ``flatten`` parameters to plot selected variable dimensions\nacross multiple plots. We will now modify the dimension ``obs_id`` to contain\nindicate the name of the county where the measure was taken. The change has to\nbe done on both ``posterior_predictive`` and ``observed_data`` groups, which is\nwhy we will use :meth:`~arviz.InferenceData.map` to apply the same function to\nboth groups. Afterwards, we will select the counties to be plotted with the\n``coords`` arg.\n\n.. plot::\n    :context: close-figs\n\n    >>> obs_county = data.posterior[\"County\"][data.constant_data[\"county_idx\"]]\n    >>> data = data.assign_coords(obs_id=obs_county, groups=\"observed_vars\")\n    >>> az.plot_ppc(data, coords={'obs_id': ['ANOKA', 'BELTRAMI']}, flatten=[])\n\nPlot the overlay using a stacked scatter plot that is particularly useful\nwhen the sample sizes are small.\n\n.. plot::\n    :context: close-figs\n\n    >>> az.plot_ppc(data, kind='scatter', flatten=[],\n    >>>             coords={'obs_id': ['AITKIN', 'BELTRAMI']})\n\nPlot random posterior predictive sub-samples.\n\n.. plot::\n    :context: close-figs\n\n    >>> az.plot_ppc(data, num_pp_samples=30, random_seed=7)\n\n\n\n\n\n\n\n","category":"method"},{"location":"api/plots/#ArviZPythonPlots.plot_rank-Tuple","page":"Plotting functions","title":"ArviZPythonPlots.plot_rank","text":"Plot rank order statistics of chains.\n\nFrom the paper: Rank plots are histograms of the ranked posterior draws (ranked over all\nchains) plotted separately for each chain.\nIf all of the chains are targeting the same posterior, we expect the ranks in each chain to be\nuniform, whereas if one chain has a different location or scale parameter, this will be\nreflected in the deviation from uniformity. If rank plots of all chains look similar, this\nindicates good mixing of the chains.\n\nThis plot was introduced by Aki Vehtari, Andrew Gelman, Daniel Simpson, Bob Carpenter,\nPaul-Christian Burkner (2021): Rank-normalization, folding, and localization:\nAn improved R-hat for assessing convergence of MCMC. Bayesian analysis, 16(2):667-718.\n\n\nParameters\n----------\ndata: obj\n    Any object that can be converted to an :class:`arviz.InferenceData` object.\n    Refer to documentation of  :func:`arviz.convert_to_dataset` for details\nvar_names: string or list of variable names\n    Variables to be plotted. Prefix the variables by ``~`` when you want to exclude\n    them from the plot.\nfilter_vars: {None, \"like\", \"regex\"}, optional, default=None\n    If `None` (default), interpret var_names as the real variables names. If \"like\",\n    interpret var_names as substrings of the real variables names. If \"regex\",\n    interpret var_names as regular expressions on the real variables names. A la\n    ``pandas.filter``.\ntransform: callable\n    Function to transform data (defaults to None i.e.the identity function)\ncoords: mapping, optional\n    Coordinates of var_names to be plotted. Passed to :meth:`xarray.Dataset.sel`\nbins: None or passed to np.histogram\n    Binning strategy used for histogram. By default uses twice the result of Sturges' formula.\n    See :func:`numpy.histogram` documentation for, other available arguments.\nkind: string\n    If bars (defaults), ranks are represented as stacked histograms (one per chain). If vlines\n    ranks are represented as vertical lines above or below ``ref_line``.\ncolors: string or list of strings\n    List with valid matplotlib colors, one color per model. Alternative a string can be passed.\n    If the string is `cycle`, it will automatically choose a color per model from matplotlib's\n    cycle. If a single color is passed, e.g. 'k', 'C2' or 'red' this color will be used for all\n    models. Defaults to `cycle`.\nref_line: boolean\n    Whether to include a dashed line showing where a uniform distribution would lie\nlabels: bool\n    whether to plot or not the x and y labels, defaults to True\nlabeller : labeller instance, optional\n    Class providing the method ``make_label_vert`` to generate the labels in the plot titles.\n    Read the :ref:`label_guide` for more details and usage examples.\ngrid : tuple\n    Number of rows and columns. Defaults to None, the rows and columns are\n    automatically inferred.\nfigsize: tuple\n    Figure size. If None it will be defined automatically.\nax: numpy array-like of matplotlib axes or bokeh figures, optional\n    A 2D array of locations into which to plot the densities. If not supplied, ArviZ will create\n    its own array of plot areas (and return it).\nbackend: str, optional\n    Select plotting backend {\"matplotlib\",\"bokeh\"}. Default \"matplotlib\".\nref_line_kwargs : dict, optional\n    Reference line keyword arguments, passed to :meth:`mpl:matplotlib.axes.Axes.axhline` or\n    :class:`bokeh:bokeh.models.Span`.\nbar_kwargs : dict, optional\n    Bars keyword arguments, passed to :meth:`mpl:matplotlib.axes.Axes.bar` or\n    :meth:`bokeh:bokeh.plotting.Figure.vbar`.\nvlines_kwargs : dict, optional\n    Vlines keyword arguments, passed to :meth:`mpl:matplotlib.axes.Axes.vlines` or\n    :meth:`bokeh:bokeh.plotting.Figure.multi_line`.\nmarker_vlines_kwargs : dict, optional\n    Marker for the vlines keyword arguments, passed to :meth:`mpl:matplotlib.axes.Axes.plot` or\n    :meth:`bokeh:bokeh.plotting.Figure.circle`.\nbackend_kwargs: bool, optional\n    These are kwargs specific to the backend being used, passed to\n    :func:`matplotlib.pyplot.subplots` or\n    :func:`bokeh.plotting.figure`. For additional documentation\n    check the plotting method of the backend.\nshow: bool, optional\n    Call backend show function.\n\nReturns\n-------\naxes: matplotlib axes or bokeh figures\n\nSee Also\n--------\nplot_trace : Plot distribution (histogram or kernel density estimates) and\n             sampled values or rank plot.\n\nExamples\n--------\nShow a default rank plot\n\n.. plot::\n    :context: close-figs\n\n    >>> import arviz as az\n    >>> data = az.load_arviz_data('centered_eight')\n    >>> az.plot_rank(data)\n\nRecreate Figure 13 from the arxiv preprint\n\n.. plot::\n    :context: close-figs\n\n    >>> data = az.load_arviz_data('centered_eight')\n    >>> az.plot_rank(data, var_names='tau')\n\nUse vlines to compare results for centered vs noncentered models\n\n.. plot::\n    :context: close-figs\n\n    >>> import matplotlib.pyplot as plt\n    >>> centered_data = az.load_arviz_data('centered_eight')\n    >>> noncentered_data = az.load_arviz_data('non_centered_eight')\n    >>> _, ax = plt.subplots(1, 2, figsize=(12, 3))\n    >>> az.plot_rank(centered_data, var_names=\"mu\", kind='vlines', ax=ax[0])\n    >>> az.plot_rank(noncentered_data, var_names=\"mu\", kind='vlines', ax=ax[1])\n\nChange the aesthetics using kwargs\n\n.. plot::\n    :context: close-figs\n\n    >>> az.plot_rank(noncentered_data, var_names=\"mu\", kind=\"vlines\",\n    >>>              vlines_kwargs={'lw':0}, marker_vlines_kwargs={'lw':3});\n\n\n\n\n\n\n\n","category":"method"},{"location":"api/plots/#ArviZPythonPlots.plot_separation-Tuple","page":"Plotting functions","title":"ArviZPythonPlots.plot_separation","text":"Separation plot for binary outcome models.\n\nModel predictions are sorted and plotted using a color code according to\nthe observed data.\n\nParameters\n----------\nidata : InferenceData\n    :class:`arviz.InferenceData` object.\ny : array, DataArray or str\n    Observed data. If str, ``idata`` must be present and contain the observed data group\ny_hat : array, DataArray or str\n    Posterior predictive samples for ``y``. It must have the same shape as ``y``. If str or\n    None, ``idata`` must contain the posterior predictive group.\ny_hat_line : bool, optional\n    Plot the sorted ``y_hat`` predictions.\nexpected_events : bool, optional\n    Plot the total number of expected events.\nfigsize : figure size tuple, optional\n    If None, size is (8 + numvars, 8 + numvars)\ntextsize: int, optional\n    Text size for labels. If None it will be autoscaled based on ``figsize``.\ncolor : str, optional\n    Color to assign to the positive class. The negative class will be plotted using the\n    same color and an `alpha=0.3` transparency.\nlegend : bool, optional\n    Show the legend of the figure.\nax: axes, optional\n    Matplotlib axes or bokeh figures.\nplot_kwargs : dict, optional\n    Additional keywords passed to :meth:`mpl:matplotlib.axes.Axes.bar` or\n    :meth:`bokeh:bokeh.plotting.Figure.vbar` for separation plot.\ny_hat_line_kwargs : dict, optional\n    Additional keywords passed to ax.plot for ``y_hat`` line.\nexp_events_kwargs : dict, optional\n    Additional keywords passed to ax.scatter for ``expected_events`` marker.\nbackend: str, optional\n    Select plotting backend {\"matplotlib\",\"bokeh\"}. Default \"matplotlib\".\nbackend_kwargs: bool, optional\n    These are kwargs specific to the backend being used, passed to\n    :func:`matplotlib.pyplot.subplots` or\n    :func:`bokeh.plotting.figure`.\nshow : bool, optional\n    Call backend show function.\n\nReturns\n-------\naxes : matplotlib axes or bokeh figures\n\nSee Also\n--------\nplot_ppc : Plot for posterior/prior predictive checks.\n\nReferences\n----------\n.. [1] Greenhill, B. *et al.*, The Separation Plot: A New Visual Method\n   for Evaluating the Fit of Binary Models, *American Journal of\n   Political Science*, (2011) see https://doi.org/10.1111/j.1540-5907.2011.00525.x\n\nExamples\n--------\nSeparation plot for a logistic regression model.\n\n.. plot::\n    :context: close-figs\n\n    >>> import arviz as az\n    >>> idata = az.load_arviz_data('classification10d')\n    >>> az.plot_separation(idata=idata, y='outcome', y_hat='outcome', figsize=(8, 1))\n\n\n\n\n\n\n\n\n","category":"method"},{"location":"api/plots/#ArviZPythonPlots.plot_trace-Tuple","page":"Plotting functions","title":"ArviZPythonPlots.plot_trace","text":"Plot distribution (histogram or kernel density estimates) and sampled values or rank plot.\n\nIf `divergences` data is available in `sample_stats`, will plot the location of divergences as\ndashed vertical lines.\n\nParameters\n----------\ndata: obj\n    Any object that can be converted to an :class:`arviz.InferenceData` object\n    Refer to documentation of :func:`arviz.convert_to_dataset` for details\nvar_names: str or list of str, optional\n    One or more variables to be plotted. Prefix the variables by ``~`` when you want\n    to exclude them from the plot.\nfilter_vars: {None, \"like\", \"regex\"}, optional, default=None\n    If `None` (default), interpret var_names as the real variables names. If \"like\",\n    interpret var_names as substrings of the real variables names. If \"regex\",\n    interpret var_names as regular expressions on the real variables names. A la\n    ``pandas.filter``.\ncoords: dict of {str: slice or array_like}, optional\n    Coordinates of var_names to be plotted. Passed to :meth:`xarray.Dataset.sel`\ndivergences: {\"bottom\", \"top\", None}, optional\n    Plot location of divergences on the traceplots.\nkind: {\"trace\", \"rank_bars\", \"rank_vlines\"}, optional\n    Choose between plotting sampled values per iteration and rank plots.\ntransform: callable, optional\n    Function to transform data (defaults to None i.e.the identity function)\nfigsize: tuple of (float, float), optional\n    If None, size is (12, variables * 2)\nrug: bool, optional\n    If True adds a rugplot of samples. Defaults to False. Ignored for 2D KDE.\n    Only affects continuous variables.\nlines: list of tuple of (str, dict, array_like), optional\n    List of (var_name, {'coord': selection}, [line, positions]) to be overplotted as\n    vertical lines on the density and horizontal lines on the trace.\ncirc_var_names : str or list of str, optional\n    List of circular variables to account for when plotting KDE.\ncirc_var_units : str\n    Whether the variables in ``circ_var_names`` are in \"degrees\" or \"radians\".\ncompact: bool, optional\n    Plot multidimensional variables in a single plot.\ncompact_prop: str or dict {str: array_like}, optional\n     Defines the property name and the property values to distinguish different\n    dimensions with compact=True.\n    When compact=True it defaults to color, it is\n    ignored otherwise.\ncombined: bool, optional\n    Flag for combining multiple chains into a single line. If False (default), chains will be\n    plotted separately.\nchain_prop: str or dict {str: array_like}, optional\n    Defines the property name and the property values to distinguish different chains.\n    If compact=True it defaults to linestyle,\n    otherwise it uses the color to distinguish\n    different chains.\nlegend: bool, optional\n    Add a legend to the figure with the chain color code.\nplot_kwargs, fill_kwargs, rug_kwargs, hist_kwargs: dict, optional\n    Extra keyword arguments passed to :func:`arviz.plot_dist`. Only affects continuous\n    variables.\ntrace_kwargs: dict, optional\n    Extra keyword arguments passed to :meth:`matplotlib.axes.Axes.plot`\nlabeller : labeller instance, optional\n    Class providing the method ``make_label_vert`` to generate the labels in the plot titles.\n    Read the :ref:`label_guide` for more details and usage examples.\nrank_kwargs : dict, optional\n    Extra keyword arguments passed to :func:`arviz.plot_rank`\naxes: axes, optional\n    Matplotlib axes or bokeh figures.\nbackend: {\"matplotlib\", \"bokeh\"}, optional\n    Select plotting backend.\nbackend_config: dict, optional\n    Currently specifies the bounds to use for bokeh axes. Defaults to value set in rcParams.\nbackend_kwargs: dict, optional\n    These are kwargs specific to the backend being used, passed to\n    :func:`matplotlib.pyplot.subplots` or\n    :func:`bokeh.plotting.figure`.\nshow: bool, optional\n    Call backend show function.\n\nReturns\n-------\naxes: matplotlib axes or bokeh figures\n\nSee Also\n--------\nplot_rank : Plot rank order statistics of chains.\n\nExamples\n--------\nPlot a subset variables and select them with partial naming\n\n.. plot::\n    :context: close-figs\n\n    >>> import arviz as az\n    >>> data = az.load_arviz_data('non_centered_eight')\n    >>> coords = {'school': ['Choate', 'Lawrenceville']}\n    >>> az.plot_trace(data, var_names=('theta'), filter_vars=\"like\", coords=coords)\n\nShow all dimensions of multidimensional variables in the same plot\n\n.. plot::\n    :context: close-figs\n\n    >>> az.plot_trace(data, compact=True)\n\nDisplay a rank plot instead of trace\n\n.. plot::\n    :context: close-figs\n\n    >>> az.plot_trace(data, var_names=[\"mu\", \"tau\"], kind=\"rank_bars\")\n\nCombine all chains into one distribution and select variables with regular expressions\n\n.. plot::\n    :context: close-figs\n\n    >>> az.plot_trace(\n    >>>     data, var_names=('^theta'), filter_vars=\"regex\", coords=coords, combined=True\n    >>> )\n\n\nPlot reference lines against distribution and trace\n\n.. plot::\n    :context: close-figs\n\n    >>> lines = (('theta_t',{'school': \"Choate\"}, [-1]),)\n    >>> az.plot_trace(data, var_names=('theta_t', 'theta'), coords=coords, lines=lines)\n\n\n\n\n\n\n\n\n","category":"method"},{"location":"api/plots/#ArviZPythonPlots.plot_violin-Tuple","page":"Plotting functions","title":"ArviZPythonPlots.plot_violin","text":"Plot posterior of traces as violin plot.\n\nNotes\n-----\nIf multiple chains are provided for a variable they will be combined\n\nParameters\n----------\ndata: obj\n    Any object that can be converted to an :class:`arviz.InferenceData` object\n    Refer to documentation of :func:`arviz.convert_to_dataset` for details\nvar_names: list of variable names, optional\n    Variables to be plotted, if None all variable are plotted. Prefix the\n    variables by ``~`` when you want to exclude them from the plot.\ncombine_dims : set_like of str, optional\n    List of dimensions to reduce. Defaults to reducing only the \"chain\" and \"draw\" dimensions.\n    See the :ref:`this section <common_combine_dims>` for usage examples.\nfilter_vars: {None, \"like\", \"regex\"}, optional, default=None\n    If `None` (default), interpret var_names as the real variables names. If \"like\",\n    interpret var_names as substrings of the real variables names. If \"regex\",\n    interpret var_names as regular expressions on the real variables names. A la\n    ``pandas.filter``.\ntransform: callable\n    Function to transform data (defaults to None i.e. the identity function).\nquartiles: bool, optional\n    Flag for plotting the interquartile range, in addition to the ``hdi_prob`` * 100%\n    intervals. Defaults to ``True``.\nrug: bool\n    If ``True`` adds a jittered rugplot. Defaults to ``False``.\nside : {\"both\", \"left\", \"right\"}, default \"both\"\n    If ``both``, both sides of the violin plot are rendered. If ``left`` or ``right``, only\n    the respective side is rendered. By separately plotting left and right halfs with\n    different data, split violin plots can be achieved.\nhdi_prob: float, optional\n    Plots highest posterior density interval for chosen percentage of density.\n    Defaults to 0.94.\nshade: float\n    Alpha blending value for the shaded area under the curve, between 0\n    (no shade) and 1 (opaque). Defaults to 0.\nbw: float or str, optional\n    If numeric, indicates the bandwidth and must be positive.\n    If str, indicates the method to estimate the bandwidth and must be\n    one of \"scott\", \"silverman\", \"isj\" or \"experimental\" when ``circular`` is ``False``\n    and \"taylor\" (for now) when ``circular`` is ``True``.\n    Defaults to \"default\" which means \"experimental\" when variable is not circular\n    and \"taylor\" when it is.\ncircular: bool, optional.\n    If ``True``, it interprets `values` is a circular variable measured in radians\n    and a circular KDE is used. Defaults to ``False``.\ngrid : tuple\n    Number of rows and columns. Defaults to None, the rows and columns are\n    automatically inferred.\nfigsize: tuple\n    Figure size. If None it will be defined automatically.\ntextsize: int\n    Text size of the point_estimates, axis ticks, and highest density interval. If None it will\n    be autoscaled based on ``figsize``.\nlabeller : labeller instance, optional\n    Class providing the method ``make_label_vert`` to generate the labels in the plot titles.\n    Read the :ref:`label_guide` for more details and usage examples.\nsharex: bool\n    Defaults to ``True``, violinplots share a common x-axis scale.\nsharey: bool\n    Defaults to ``True``, violinplots share a common y-axis scale.\nax: numpy array-like of matplotlib axes or bokeh figures, optional\n    A 2D array of locations into which to plot the densities. If not supplied, Arviz will create\n    its own array of plot areas (and return it).\nshade_kwargs: dicts, optional\n    Additional keywords passed to :meth:`matplotlib.axes.Axes.fill_between`, or\n    :meth:`matplotlib.axes.Axes.barh` to control the shade.\nrug_kwargs: dict\n    Keywords passed to the rug plot. If true only the right half side of the violin will be\n    plotted.\nbackend: str, optional\n    Select plotting backend {\"matplotlib\",\"bokeh\"}. Default to \"matplotlib\".\nbackend_kwargs: bool, optional\n    These are kwargs specific to the backend being used, passed to\n    :func:`matplotlib.pyplot.subplots` or :func:`bokeh.plotting.figure`.\n    For additional documentation check the plotting method of the backend.\nshow: bool, optional\n    Call backend show function.\n\nReturns\n-------\naxes: matplotlib axes or bokeh figures\n\nSee Also\n--------\nplot_forest: Forest plot to compare HDI intervals from a number of distributions.\n\nExamples\n--------\nShow a default violin plot\n\n.. plot::\n    :context: close-figs\n\n    >>> import arviz as az\n    >>> data = az.load_arviz_data('centered_eight')\n    >>> az.plot_violin(data)\n\n\n\n\n\n\n\n\n","category":"method"}]
}
